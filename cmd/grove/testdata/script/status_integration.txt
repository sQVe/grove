# grove status integration tests
# Tests status output with real git state

# Create grove workspace via clone
mkdir testrepo
exec git init testrepo
cd testrepo
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b feature/with-slash
exec git checkout main
cd ..

mkdir workspace
exec grove clone file://$WORK/testrepo workspace --branches main
cd workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"

## Argument validation

# Extra arguments → error (treated as unknown subcommand)
! exec grove status extra-arg
stderr 'unknown command'

## Basic status tests

# Test basic status shows branch (no dirty indicator when clean)
exec grove status --plain
stdout '\* main'
! stdout '\[dirty\]'
! stderr .

# Test status with --json
exec grove status --json
stdout '"branch":'
stdout '"main"'
stdout '"path":'
stdout '"dirty": false'
! stderr .

# Test status with --verbose shows path sub-item
exec grove status --verbose --plain
stdout '\* main'
stdout '> path:'
! stderr .

## Dirty detection

# Create uncommitted file
cp $WORK/README.md dirty.txt
exec grove status --plain
stdout '\[dirty\]'
! stderr .

# Clean up
rm dirty.txt

## Stash detection

# Create and stash a change
cp $WORK/README.md stash-me.txt
exec git add stash-me.txt
exec git stash
exec grove status --verbose --plain
stdout 'stashes:'
! stderr .

# Clear stash
exec git stash drop

## Subdirectory handling

# Test status from subdirectory
cd $WORK/workspace/main
mkdir -p src/components
cd src/components
exec grove status --plain
stdout '\* main'
! stdout '\[dirty\]'
! stderr .

# Test status --json from subdirectory
exec grove status --json
stdout '"branch": "main"'
! stderr .

## Error handling

# Test not in workspace error
mkdir $WORK/outside
cd $WORK/outside
! exec grove status
stderr '^✗ not in a grove workspace'

# Test not in worktree error (from workspace root)
cd $WORK/workspace
! exec grove status
stderr '^✗ failed to check changes.*must be run in a work tree'

cd main

## Feature branch with slashes

# Add worktree for branch with slashes
exec grove add feature/with-slash
cd ../feature-with-slash
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec grove status --plain
# Output format: * worktree-name [branch-name]
stdout '\* feature-with-slash'
stdout '\[feature/with-slash\]'
! stderr .
exec grove status --json
stdout '"branch": "feature/with-slash"'
! stderr .
cd ../main

## Lock status

# Locked worktree shows [locked] indicator
exec grove lock feature-with-slash --reason 'Testing lock'
cd ../feature-with-slash
exec grove status --plain
stdout '\[locked\]'
! stderr .

# Verbose shows lock reason
exec grove status --verbose --plain
stdout 'lock reason: Testing lock'
! stderr .

# JSON shows lock status
exec grove status --json
stdout '"locked": true'
stdout '"lock_reason": "Testing lock"'
! stderr .

cd ../main
exec grove unlock feature-with-slash

## More dirty states

# Modified tracked file → dirty
exec sh -c 'echo "modified" >> README.md'
exec grove status --plain
stdout '\[dirty\]'
! stderr .

# JSON shows dirty: true
exec grove status --json
stdout '"dirty": true'
! stderr .

# Restore file
exec git checkout README.md

# Staged changes → dirty
exec sh -c 'echo "staged" >> README.md'
exec git add README.md
exec grove status --plain
stdout '\[dirty\]'
! stderr .

# Restore
exec git reset HEAD README.md
exec git checkout README.md

## Sync status fields in JSON

# JSON includes ahead/behind fields (values depend on upstream state)
exec grove status --json
stdout '"ahead":'
stdout '"behind":'
stdout '"no_upstream":'
! stderr .

## --json + --verbose (JSON takes precedence)

exec grove status --json --verbose
stdout '"branch":'
# JSON output, not verbose text format
! stdout '> path:'
! stderr .

## Detached HEAD

# First create a second commit so we can detach to a previous one
exec sh -c 'echo "second" >> README.md'
exec git add README.md
exec git commit -m 'second commit'

# Checkout specific commit (detached HEAD)
exec git checkout HEAD~1
exec grove status --plain
stdout 'detached'
! stderr .

exec grove status --json
stdout '"detached": true'
! stderr .

# Return to branch
exec git checkout main

## Cleanup
exec grove remove feature-with-slash

-- README.md --
# Test

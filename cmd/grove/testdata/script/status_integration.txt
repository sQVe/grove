# Create grove workspace via clone
mkdir testrepo
exec git init testrepo
cd testrepo
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
cd ..

mkdir workspace
exec grove clone file://$WORK/testrepo workspace --branches main
cd workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"

## Basic status tests

# Test basic status shows branch (no dirty indicator when clean)
exec grove status --plain
stdout '\* main'
! stdout '\[dirty\]'
! stderr .

# Test status with --json
exec grove status --json
stdout '"branch":'
stdout '"main"'
stdout '"path":'
stdout '"dirty": false'
! stderr .

# Test status with --verbose shows path sub-item
exec grove status --verbose --plain
stdout '\* main'
stdout '> path:'
! stderr .

## Dirty detection

# Create uncommitted file
cp $WORK/README.md dirty.txt
exec grove status --plain
stdout '\[dirty\]'
! stderr .

# Clean up
rm dirty.txt

## Stash detection

# Create and stash a change
cp $WORK/README.md stash-me.txt
exec git add stash-me.txt
exec git stash
exec grove status --verbose --plain
stdout 'stashes:'
! stderr .

# Clear stash
exec git stash drop

## Subdirectory handling

# Test status from subdirectory
cd $WORK/workspace/main
mkdir -p src/components
cd src/components
exec grove status --plain
stdout '\* main'
! stdout '\[dirty\]'
! stderr .

# Test status --json from subdirectory
exec grove status --json
stdout '"branch": "main"'
! stderr .

## Error handling

# Test not in workspace error
cd /tmp
! exec grove status
stderr '^✗ not in a grove workspace'

# Test not in worktree error (from workspace root)
cd $WORK/workspace
! exec grove status
stderr '^✗ failed to check changes.*must be run in a work tree'

-- README.md --
# Test

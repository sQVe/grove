# grove init convert integration tests
# Tests repository conversion to grove workspace

## Success: Basic conversion
mkdir convert-basic
cd convert-basic
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec grove init convert
stderr 'Converted repository to grove workspace'
stderr 'convert-basic'
exists .bare
exists .git
exists main/test-file.txt
cd ..

## Success: Realistic directory structure
mkdir convert-realistic
cd convert-realistic
exec git init
mkdir -p .github/workflows docs/api src/components
exec sh -c 'echo "name: CI" > .github/workflows/ci.yml'
exec sh -c 'echo "API docs" > docs/api/README.md'
exec sh -c 'echo "package main" > src/main.go'
exec sh -c 'echo "export default {}" > src/components/Button.tsx'
exec git add .
exec git commit -m 'initial commit'
exec grove init convert
stderr 'Converted repository to grove workspace'
stderr 'convert-realistic'
# Verify files moved to worktree
exists main/.github/workflows/ci.yml
exists main/docs/api/README.md
exists main/src/main.go
exists main/src/components/Button.tsx
# CRITICAL: Verify root directory is clean
! exists .github
! exists docs
! exists src
# Verify only expected items in root: . .. .bare .git main = 5 entries
exec sh -c 'ls -a | wc -l'
stdout '^\s*5\s*$'
cd ..

## Success: --branches flag creates worktrees
mkdir convert-branches
cd convert-branches
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout -b 'feat/user-auth'
exec git checkout main
exec grove init convert --branches main,develop,feat/user-auth
stderr 'Converted repository to grove workspace'
stderr 'convert-branches'
stderr 'Creating worktrees'
# Worktrees created in order specified in --branches flag
stderr '✓ main'
stderr '✓ develop'
stderr '✓ feat-user-auth'
exists .bare
exists .git
exists main/test-file.txt
exists develop
exists feat-user-auth
# All worktrees get checked out with their respective branch content
exists develop/test-file.txt
exists feat-user-auth/test-file.txt
cd ..

## Success: Preserves git-ignored files
mkdir convert-preserve
cd convert-preserve
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout main
# Create ignored files that match default preserve patterns
exec sh -c 'echo "NODE_ENV=development" > .env'
exec sh -c 'echo "LOCAL=true" > .env.local'
exec sh -c 'echo "logs/" > .gitignore'
exec sh -c 'echo ".env*" >> .gitignore'
exec git add .gitignore
exec git commit -m 'add gitignore'
exec grove init convert --branches main,develop
stderr 'Converted repository to grove workspace'
stderr 'convert-preserve'
stderr 'Creating worktrees'
# Worktrees created in order specified in --branches flag
stderr '✓ main'
stderr '✓ develop'
exists .bare
exists .git
# Verify preserved files exist in all worktrees
exists main/test-file.txt
exists main/.env
exists main/.env.local
exists develop/test-file.txt
exists develop/.env
exists develop/.env.local
cd ..

## Success: Custom preserve patterns from config
mkdir convert-custom-patterns
cd convert-custom-patterns
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout main
# Set custom preserve patterns
exec git config grove.preserve '*.secret'
exec git config --add grove.preserve 'custom.*'
# Create files that match custom patterns
exec sh -c 'echo "secret data" > api.secret'
exec sh -c 'echo "custom config" > custom.config'
exec sh -c 'echo "logs/" > .gitignore'
exec sh -c 'echo "*.secret" >> .gitignore'
exec sh -c 'echo "custom.*" >> .gitignore'
exec git add .gitignore
exec git commit -m 'add gitignore'
exec grove init convert --branches main,develop
stderr 'Converted repository to grove workspace'
stderr 'convert-custom-patterns'
stderr 'Creating worktrees'
stderr '✓ main'
stderr '✓ develop'
stderr 'Found 2 ignored files/directories matching patterns:'
exists .bare
exists .git
# Verify custom pattern files are preserved in all worktrees
exists main/test-file.txt
exists main/api.secret
exists main/custom.config
exists develop/test-file.txt
exists develop/api.secret
exists develop/custom.config
cd ..

## Error: Mixed tracked and untracked files
mkdir convert-mixed-files
cd convert-mixed-files
exec git init
mkdir src build
exec sh -c 'echo "tracked code" > src/main.go'
exec sh -c 'echo "tracked test" > src/main_test.go'
exec git add src/
exec git commit -m 'tracked files'
exec sh -c 'echo "NODE_ENV=development" > .env'
exec sh -c 'echo "output" > build/main.js'
mkdir -p node_modules/package
exec sh -c 'echo "{}" > node_modules/package/package.json'
! exec grove init convert
stderr '^✗ cannot convert: repository has uncommitted changes'
cd ..

## Success: File integrity check
mkdir convert-integrity
cd convert-integrity
exec git init
mkdir -p deep/nested/structure
exec sh -c 'echo "level1" > file1.txt'
exec sh -c 'echo "level2" > deep/file2.txt'
exec sh -c 'echo "level3" > deep/nested/file3.txt'
exec sh -c 'echo "level4" > deep/nested/structure/file4.txt'
exec git add .
exec git commit -m 'nested structure'
# We have exactly 4 files in the nested structure
exec grove init convert
# Verify all 4 files exist in worktree after convert
exec sh -c 'find main -type f -not -name ".git" | wc -l'
stdout '^\s*4\s*$'
# Verify structure preserved
exists main/file1.txt
exists main/deep/file2.txt
exists main/deep/nested/file3.txt
exists main/deep/nested/structure/file4.txt
# Root should be clean
! exists file1.txt
! exists deep
cd ..

## Error: Ongoing merge fails
mkdir convert-merge
cd convert-merge
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b branch2
exec sh -c 'echo "conflict" > test-file.txt'
exec git add .
exec git commit -m 'conflict'
exec git checkout main
exec sh -c 'echo "other" > test-file.txt'
exec git add .
exec git commit -m 'other'
! exec git merge branch2
! exec grove init convert
stderr '^✗ cannot convert: repository has unresolved conflicts'
cd ..

## Error: Unresolved conflicts
mkdir convert-conflicts
cd convert-conflicts
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b conflict-branch
exec sh -c 'echo "conflict content" > test-file.txt'
exec git add .
exec git commit -m 'conflict commit'
exec git checkout main
exec sh -c 'echo "main content" > test-file.txt'
exec git add .
exec git commit -m 'main commit'
! exec git merge conflict-branch
exec git reset --hard HEAD
! exec git merge --no-commit conflict-branch
! exec grove init convert
stderr '^✗ cannot convert: repository has unresolved conflicts'
cd ..

## Success: Remote-only branch
mkdir convert-remote-branch
cd convert-remote-branch
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b feature-branch
exec git checkout main
# Simulate a remote by creating bare repo and cloning it
exec git clone --bare . ../remote.git
exec git remote add origin ../remote.git
exec git push -u origin main
exec git push origin feature-branch
# Remove local feature branch to simulate remote-only scenario
exec git branch -D feature-branch
# Verify branch only exists remotely
exec git branch -a
stdout 'remotes/origin/feature-branch'
! stdout '^  feature-branch$'
# Convert with remote branch should work
exec grove init convert --branches feature-branch
stderr 'Converted repository to grove workspace'
stderr '✓ main'
stderr '✓ feature-branch'
exists .bare
exists .git
exists main/test-file.txt
exists feature-branch
cd ..

## Rollback: Worktree blocked by existing directory
mkdir convert-rollback-test
cd convert-rollback-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout main
# Create a directory that will block the main worktree creation
mkdir main
exec sh -c 'echo "blocking file" > main/blocker.txt'
exec git add .
exec git commit -m 'add blocking directory'
! exec grove init convert --branches main,develop
stderr '^✗ failed to create worktree'
# Verify rollback restored original state
! exists .bare
exists .git
exists test-file.txt
# Verify git repository still works
exec git log --oneline -n 1
stdout 'add blocking directory'
# Clean up blocking directory
exec rm -rf main
cd ..

# Test early validation prevents conversion with nonexistent branch
mkdir convert-invalid-branch-test  
cd convert-invalid-branch-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Try to convert with nonexistent branch - should fail during validation
! exec grove init convert --branches main,nonexistent-branch
stderr '^✗ branch.*does not exist'
# Verify no changes were made since validation failed early
! exists .bare
exists .git
exists test-file.txt
cd ..

# Test lock file cleanup on successful conversion
mkdir convert-lock-success-test
cd convert-lock-success-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Convert and verify lock file is cleaned up
exec grove init convert
! exists .grove-convert.lock
exists .bare
exists .git
exists main/test-file.txt
cd ..

# Test lock file cleanup on conversion failure
mkdir convert-lock-failure-test
cd convert-lock-failure-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Create blocking directory to force conversion failure
mkdir main
exec sh -c 'echo "blocker" > main/blocker.txt'
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '^✗ failed to create worktree'
# Verify lock file was cleaned up even on failure
! exists .grove-convert.lock
exists .git
exists test-file.txt
cd ..

# Test symlink handling during conversion
# Skip on Windows: ln -s and readlink are Unix-specific
[!windows] mkdir convert-symlink-test
[!windows] cd convert-symlink-test
[!windows] exec git init
[!windows] cp ../test-file.txt .
[!windows] exec ln -s test-file.txt link-to-file.txt
[!windows] exec git add .
[!windows] exec git commit -m 'initial commit with symlink'
[!windows] exec grove init convert
[!windows] exists main/test-file.txt
[!windows] exists main/link-to-file.txt
[!windows] exec readlink main/link-to-file.txt
[!windows] stdout '^test-file.txt$'
[!windows] cd ..

# Test symlink restoration during rollback
[!windows] mkdir convert-symlink-rollback-test
[!windows] cd convert-symlink-rollback-test
[!windows] exec git init
[!windows] cp ../test-file.txt .
[!windows] exec ln -s test-file.txt link-to-file.txt
[!windows] exec git add .
[!windows] exec git commit -m 'initial commit with symlink'
[!windows] mkdir main
[!windows] exec sh -c 'echo "blocker" > main/blocker.txt'
[!windows] exec git add .
[!windows] exec git commit -m 'add blocker'
[!windows] ! exec grove init convert
[!windows] stderr '^✗ failed to create worktree'
[!windows] exists test-file.txt
[!windows] exists link-to-file.txt
[!windows] exec readlink link-to-file.txt
[!windows] stdout '^test-file.txt$'
[!windows] cd ..

# Test file restoration on rollback failure with multiple files
mkdir convert-file-restore-test
cd convert-file-restore-test
exec git init
cp ../test-file.txt .
cp ../untracked.txt another-file.txt
exec git add .
exec git commit -m 'initial commit with multiple files'
# Create blocking directory to force rollback
mkdir main
exec sh -c 'echo "blocker" > main/blocker.txt'
exec git add .
exec git commit -m 'add blocker'
# Verify files exist before conversion attempt
exists test-file.txt
exists another-file.txt
! exec grove init convert
stderr '^✗ failed to create worktree'
# Verify all files were restored to root after rollback
exists test-file.txt
exists another-file.txt
# Verify .git directory is restored (not .bare)
exists .git
! exists .bare
cd ..

# Test directory hierarchy preservation and restoration on rollback
mkdir convert-hierarchy-test
cd convert-hierarchy-test
exec git init
mkdir subdir
mkdir subdir/nested
cp ../test-file.txt subdir/
cp ../test-file.txt subdir/nested/nested-file.txt
exec git add .
exec git commit -m 'initial commit with directory hierarchy'
# Create blocking directory to force rollback
mkdir main
exec sh -c 'echo "blocker" > main/blocker.txt'
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '^✗ failed to create worktree'
# Verify directory hierarchy was restored correctly
exists subdir/test-file.txt
exists subdir/nested/nested-file.txt
# Verify .git directory is restored
exists .git
! exists .bare
cd ..

# Test git config restoration after rollback
mkdir convert-gitconfig-test
cd convert-gitconfig-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Verify initial config state
exec sh -c 'test "$(git config --bool core.bare)" = "false" || test -z "$(git config --bool core.bare)"'
# Create blocking directory to force rollback
mkdir main
exec sh -c 'echo "blocker" > main/blocker.txt'
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '^✗ failed to create worktree'
# Verify git config was restored to non-bare
exec sh -c 'test "$(git config --bool core.bare)" = "false" || test -z "$(git config --bool core.bare)"'
# Verify repository still functions normally
exec git status
exists .git
! exists .bare
cd ..

# Test rollback with mixed file types (regular, hidden)
mkdir convert-mixed-files-test
cd convert-mixed-files-test
exec git init
cp ../test-file.txt .
exec sh -c 'echo "hidden content" > .hidden-file'
exec sh -c 'echo "script content" > script.sh'
exec git add .
exec git commit -m 'initial commit with mixed file types'
# Create blocking directory to force rollback
mkdir main
exec sh -c 'echo "blocker" > main/blocker.txt'
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '^✗ failed to create worktree'
# Verify all file types were restored
exists test-file.txt
exists .hidden-file
exists script.sh
exists .git
! exists .bare
cd ..

# Test rollback behavior with multiple worktrees created during conversion
mkdir convert-multiple-worktrees-test
cd convert-multiple-worktrees-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Create additional branch for multiple worktree test
exec git checkout -b feature
exec sh -c 'echo "feature content" > feature.txt'
exec git add .
exec git commit -m 'feature commit'
exec git checkout main
# Create blocking directory to force rollback after worktrees are created
mkdir main
exec sh -c 'echo "blocker" > main/blocker.txt'
exec git add .
exec git commit -m 'add blocker'
# Attempt conversion with multiple branches - should fail and rollback
! exec grove init convert --branches feature,main
stderr '^✗ failed to create worktree'
# Verify rollback cleaned up created worktrees (main directory should still exist as it was part of original repo)
! exists feature
exists main
exists main/blocker.txt
# Verify .git directory restored and repository works
exists .git
! exists .bare
exec git status
exec git branch
cd ..

# Note: Additional rollback scenarios could include permission denied or disk full,
# but these are difficult to test reliably in a cross-platform manner.
# The tests above now provide comprehensive coverage of the rollback mechanism.

-- test-file.txt --
This is a test file

-- untracked.txt --
This file is untracked

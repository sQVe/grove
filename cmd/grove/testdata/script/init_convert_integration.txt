# grove init convert integration tests
# Tests repository conversion to grove workspace

## Success: Basic conversion
mkdir convert-basic
cd convert-basic
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec grove init convert
stderr 'Converted repository to grove workspace'
stderr 'convert-basic'
exists .bare
exists .git
exists main/test-file.txt
cd ..

## Success: Realistic directory structure
mkdir convert-realistic
cd convert-realistic
exec git init
mkdir -p .github/workflows docs/api src/components
cp $WORK/ci-yml .github/workflows/ci.yml
cp $WORK/api-readme docs/api/README.md
cp $WORK/main-go src/main.go
cp $WORK/button-tsx src/components/Button.tsx
exec git add .
exec git commit -m 'initial commit'
exec grove init convert
stderr 'Converted repository to grove workspace'
stderr 'convert-realistic'
# Verify files moved to worktree
exists main/.github/workflows/ci.yml
exists main/docs/api/README.md
exists main/src/main.go
exists main/src/components/Button.tsx
# CRITICAL: Verify root directory is clean
! exists .github
! exists docs
! exists src
# Verify only expected items in root: . .. .bare .git main = 5 entries
exec sh -c 'ls -a | wc -l'
stdout '^\s*5\s*$'
cd ..

## Success: --branches flag creates worktrees
mkdir convert-branches
cd convert-branches
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout -b 'feat/user-auth'
exec git checkout main
exec grove init convert --branches main,develop,feat/user-auth
stderr 'Converted repository to grove workspace'
stderr 'convert-branches'
stderr 'Creating worktrees'
# Worktrees created in order specified in --branches flag
stderr '✓ main'
stderr '✓ develop'
stderr '✓ feat-user-auth'
exists .bare
exists .git
exists main/test-file.txt
exists develop
exists feat-user-auth
# All worktrees get checked out with their respective branch content
exists develop/test-file.txt
exists feat-user-auth/test-file.txt
cd ..

## Success: Preserves git-ignored files
mkdir convert-preserve
cd convert-preserve
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout main
# Create ignored files that match default preserve patterns
cp $WORK/env-dev .env
cp $WORK/env-local .env.local
cp $WORK/gitignore-preserve .gitignore
exec git add .gitignore
exec git commit -m 'add gitignore'
exec grove init convert --branches main,develop
stderr 'Converted repository to grove workspace'
stderr 'convert-preserve'
stderr 'Creating worktrees'
# Worktrees created in order specified in --branches flag
stderr '✓ main'
stderr '✓ develop'
exists .bare
exists .git
# Verify preserved files exist in all worktrees
exists main/test-file.txt
exists main/.env
exists main/.env.local
exists develop/test-file.txt
exists develop/.env
exists develop/.env.local
cd ..

## Success: Custom preserve patterns from config
mkdir convert-custom-patterns
cd convert-custom-patterns
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout main
# Set custom preserve patterns
exec git config grove.preserve '*.secret'
exec git config --add grove.preserve 'custom.*'
# Create files that match custom patterns
cp $WORK/secret-data api.secret
cp $WORK/custom-config custom.config
cp $WORK/gitignore-custom .gitignore
exec git add .gitignore
exec git commit -m 'add gitignore'
exec grove init convert --branches main,develop
stderr 'Converted repository to grove workspace'
stderr 'convert-custom-patterns'
stderr 'Creating worktrees'
stderr '✓ main'
stderr '✓ develop'
stderr 'Found 2 ignored files/directories matching patterns:'
exists .bare
exists .git
# Verify custom pattern files are preserved in all worktrees
exists main/test-file.txt
exists main/api.secret
exists main/custom.config
exists develop/test-file.txt
exists develop/api.secret
exists develop/custom.config
cd ..

## Error: Mixed tracked and untracked files
mkdir convert-mixed-files
cd convert-mixed-files
exec git init
mkdir src build
cp $WORK/main-go src/main.go
cp $WORK/main-test-go src/main_test.go
exec git add src/
exec git commit -m 'tracked files'
cp $WORK/env-dev .env
cp $WORK/build-output build/main.js
mkdir -p node_modules/package
cp $WORK/package-json node_modules/package/package.json
! exec grove init convert
stderr '✗ cannot convert: repository has uncommitted changes'
cd ..

## Success: File integrity check
mkdir convert-integrity
cd convert-integrity
exec git init
mkdir -p deep/nested/structure
cp $WORK/level1 file1.txt
cp $WORK/level2 deep/file2.txt
cp $WORK/level3 deep/nested/file3.txt
cp $WORK/level4 deep/nested/structure/file4.txt
exec git add .
exec git commit -m 'nested structure'
# We have exactly 4 files in the nested structure
exec grove init convert
# Verify all 4 files exist in worktree after convert
exec sh -c 'find main -type f -not -name ".git" | wc -l'
stdout '^\s*4\s*$'
# Verify structure preserved
exists main/file1.txt
exists main/deep/file2.txt
exists main/deep/nested/file3.txt
exists main/deep/nested/structure/file4.txt
# Root should be clean
! exists file1.txt
! exists deep
cd ..

## Error: Ongoing merge fails
mkdir convert-merge
cd convert-merge
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b branch2
cp $WORK/conflict test-file.txt
exec git add .
exec git commit -m 'conflict'
exec git checkout main
cp $WORK/other test-file.txt
exec git add .
exec git commit -m 'other'
! exec git merge branch2
! exec grove init convert
stderr '✗ cannot convert: repository has unresolved conflicts'
cd ..

## Success: Remote-only branch
mkdir convert-remote-branch
cd convert-remote-branch
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b feature-branch
exec git checkout main
# Simulate a remote by creating bare repo and cloning it
exec git clone --bare . ../remote.git
exec git remote add origin ../remote.git
exec git push -u origin main
exec git push origin feature-branch
# Remove local feature branch to simulate remote-only scenario
exec git branch -D feature-branch
# Verify branch only exists remotely
exec git branch -a
stdout 'remotes/origin/feature-branch'
! stdout '^  feature-branch$'
# Convert with remote branch should work
exec grove init convert --branches feature-branch
stderr 'Converted repository to grove workspace'
stderr '✓ main'
stderr '✓ feature-branch'
exists .bare
exists .git
exists main/test-file.txt
exists feature-branch
cd ..

## Rollback: Worktree blocked by existing directory
mkdir convert-rollback-test
cd convert-rollback-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b develop
exec git checkout main
# Create a directory that will block the main worktree creation
mkdir main
cp $WORK/blocker main/blocker.txt
exec git add .
exec git commit -m 'add blocking directory'
! exec grove init convert --branches main,develop
stderr '✗ failed to create worktree'
# Verify rollback restored original state
! exists .bare
exists .git
exists test-file.txt
# Verify git repository still works
exec git log --oneline -n 1
stdout 'add blocking directory'
# Clean up blocking directory
exec rm -rf main
cd ..

# Test early validation prevents conversion with nonexistent branch
mkdir convert-invalid-branch-test
cd convert-invalid-branch-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Try to convert with nonexistent branch - should fail during validation
! exec grove init convert --branches main,nonexistent-branch
stderr '✗ branch.*does not exist'
# Verify no changes were made since validation failed early
! exists .bare
exists .git
exists test-file.txt
cd ..

# Test lock file cleanup on successful conversion
mkdir convert-lock-success-test
cd convert-lock-success-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Convert and verify lock file is cleaned up
exec grove init convert
! exists .grove-convert.lock
exists .bare
exists .git
exists main/test-file.txt
cd ..

# Test lock file cleanup on conversion failure
mkdir convert-lock-failure-test
cd convert-lock-failure-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Create blocking directory to force conversion failure
mkdir main
cp $WORK/blocker main/blocker.txt
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '✗ failed to create worktree'
# Verify lock file was cleaned up even on failure
! exists .grove-convert.lock
exists .git
exists test-file.txt
cd ..

# Test symlink handling during conversion
# Skip on Windows: ln -s and readlink are Unix-specific
[!windows] mkdir convert-symlink-test
[!windows] cd convert-symlink-test
[!windows] exec git init
[!windows] cp ../test-file.txt .
[!windows] exec ln -s test-file.txt link-to-file.txt
[!windows] exec git add .
[!windows] exec git commit -m 'initial commit with symlink'
[!windows] exec grove init convert
[!windows] exists main/test-file.txt
[!windows] exists main/link-to-file.txt
[!windows] exec readlink main/link-to-file.txt
[!windows] stdout '^test-file.txt$'
[!windows] cd ..

# Test symlink restoration during rollback
[!windows] mkdir convert-symlink-rollback-test
[!windows] cd convert-symlink-rollback-test
[!windows] exec git init
[!windows] cp ../test-file.txt .
[!windows] exec ln -s test-file.txt link-to-file.txt
[!windows] exec git add .
[!windows] exec git commit -m 'initial commit with symlink'
[!windows] mkdir main
[!windows] cp $WORK/blocker main/blocker.txt
[!windows] exec git add .
[!windows] exec git commit -m 'add blocker'
[!windows] ! exec grove init convert
[!windows] stderr '✗ failed to create worktree'
[!windows] exists test-file.txt
[!windows] exists link-to-file.txt
[!windows] exec readlink link-to-file.txt
[!windows] stdout '^test-file.txt$'
[!windows] cd ..

# Test file restoration on rollback failure with multiple files
mkdir convert-file-restore-test
cd convert-file-restore-test
exec git init
cp ../test-file.txt .
cp ../untracked.txt another-file.txt
exec git add .
exec git commit -m 'initial commit with multiple files'
# Create blocking directory to force rollback
mkdir main
cp $WORK/blocker main/blocker.txt
exec git add .
exec git commit -m 'add blocker'
# Verify files exist before conversion attempt
exists test-file.txt
exists another-file.txt
! exec grove init convert
stderr '✗ failed to create worktree'
# Verify all files were restored to root after rollback
exists test-file.txt
exists another-file.txt
# Verify .git directory is restored (not .bare)
exists .git
! exists .bare
cd ..

# Test directory hierarchy preservation and restoration on rollback
mkdir convert-hierarchy-test
cd convert-hierarchy-test
exec git init
mkdir subdir
mkdir subdir/nested
cp ../test-file.txt subdir/
cp ../test-file.txt subdir/nested/nested-file.txt
exec git add .
exec git commit -m 'initial commit with directory hierarchy'
# Create blocking directory to force rollback
mkdir main
cp $WORK/blocker main/blocker.txt
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '✗ failed to create worktree'
# Verify directory hierarchy was restored correctly
exists subdir/test-file.txt
exists subdir/nested/nested-file.txt
# Verify .git directory is restored
exists .git
! exists .bare
cd ..

# Test git config restoration after rollback
mkdir convert-gitconfig-test
cd convert-gitconfig-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Verify initial config state
exec sh -c 'test "$(git config --bool core.bare)" = "false" || test -z "$(git config --bool core.bare)"'
# Create blocking directory to force rollback
mkdir main
cp $WORK/blocker main/blocker.txt
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '✗ failed to create worktree'
# Verify git config was restored to non-bare
exec sh -c 'test "$(git config --bool core.bare)" = "false" || test -z "$(git config --bool core.bare)"'
# Verify repository still functions normally
exec git status
exists .git
! exists .bare
cd ..

# Test rollback with mixed file types (regular, hidden)
mkdir convert-mixed-files-test
cd convert-mixed-files-test
exec git init
cp ../test-file.txt .
cp $WORK/hidden-file .hidden-file
cp $WORK/script-sh script.sh
exec git add .
exec git commit -m 'initial commit with mixed file types'
# Create blocking directory to force rollback
mkdir main
cp $WORK/blocker main/blocker.txt
exec git add .
exec git commit -m 'add blocker'
! exec grove init convert
stderr '✗ failed to create worktree'
# Verify all file types were restored
exists test-file.txt
exists .hidden-file
exists script.sh
exists .git
! exists .bare
cd ..

# Test rollback behavior with multiple worktrees created during conversion
mkdir convert-multiple-worktrees-test
cd convert-multiple-worktrees-test
exec git init
cp ../test-file.txt .
exec git add .
exec git commit -m 'initial commit'
# Create additional branch for multiple worktree test
exec git checkout -b feature
cp $WORK/feature-content feature.txt
exec git add .
exec git commit -m 'feature commit'
exec git checkout main
# Create blocking directory to force rollback after worktrees are created
mkdir main
cp $WORK/blocker main/blocker.txt
exec git add .
exec git commit -m 'add blocker'
# Attempt conversion with multiple branches - should fail and rollback
! exec grove init convert --branches feature,main
stderr '✗ failed to create worktree'
# Verify rollback cleaned up created worktrees (main directory should still exist as it was part of original repo)
! exists feature
exists main
exists main/blocker.txt
# Verify .git directory restored and repository works
exists .git
! exists .bare
exec git status
exec git branch
cd ..

# Note: Additional rollback scenarios could include permission denied or disk full,
# but these are difficult to test reliably in a cross-platform manner.
# The tests above now provide comprehensive coverage of the rollback mechanism.

-- test-file.txt --
This is a test file

-- untracked.txt --
This file is untracked

-- ci-yml --
name: CI

-- api-readme --
API docs

-- main-go --
package main

-- button-tsx --
export default {}

-- env-dev --
NODE_ENV=development

-- env-local --
LOCAL=true

-- gitignore-preserve --
logs/
.env*

-- secret-data --
secret data

-- custom-config --
custom config

-- gitignore-custom --
logs/
*.secret
custom.*

-- main-test-go --
tracked test

-- build-output --
output

-- package-json --
{}

-- level1 --
level1

-- level2 --
level2

-- level3 --
level3

-- level4 --
level4

-- conflict --
conflict

-- other --
other

-- blocker --
blocking file

-- hidden-file --
hidden content

-- script-sh --
script content

-- feature-content --
feature content

# grove move advanced tests
# Tests dirty state, locked worktrees, directory validation, sanitization

# Setup workspace
mkdir testrepo
exec git init testrepo
cd testrepo
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b feature-branch
exec git checkout main
cd ..

mkdir workspace
exec grove clone file://$WORK/testrepo workspace
cd workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"

## Dirty State Check

# Modified tracked files → error
exec grove add dirty-modified
cp $WORK/modified.txt ../dirty-modified/README.md
exec git -C ../dirty-modified status --porcelain
! exec grove move dirty-modified dirty-renamed
stderr '✗ .*uncommitted changes'
exec grove remove -f dirty-modified

# Staged but not committed → error
exec grove add dirty-staged
cp $WORK/staged.txt ../dirty-staged/README.md
exec git -C ../dirty-staged status --porcelain
exec git -C ../dirty-staged add README.md
! exec grove move dirty-staged staged-renamed
stderr '✗ .*uncommitted changes'
exec grove remove -f dirty-staged

# Untracked files → also treated as dirty (consistent with remove)
exec grove add dirty-untracked
cp $WORK/untracked.txt ../dirty-untracked/untracked.txt
exec git -C ../dirty-untracked status --porcelain
! exec grove move dirty-untracked untracked-renamed
stderr '✗ .*uncommitted changes'
exec grove remove -f dirty-untracked

# Clean worktree → allowed
exec grove add clean-test
exec grove move clean-test clean-renamed
stderr 'Renamed clean-test to clean-renamed'
exec grove remove clean-renamed

## Locked Worktree Check

# Worktree is locked → error
exec grove add locked-test
exec grove lock locked-test
! exec grove move locked-test locked-renamed
stderr '✗ worktree is locked'
exec grove unlock locked-test
exec grove remove locked-test

# Unlocked worktree → allowed
exec grove add unlocked-test
exec grove move unlocked-test unlocked-renamed
stderr 'Renamed unlocked-test to unlocked-renamed'
exec grove remove unlocked-renamed

## Directory Validation

# New directory already exists → error
exec grove add dir-exists-test
mkdir ../blocking-dir
! exec grove move dir-exists-test blocking-dir
stderr '✗ directory.*already exists'
exec rmdir ../blocking-dir
exec grove remove dir-exists-test

# Sanitized name causes collision → error
exec grove add sanitized-collision
mkdir ../sanitized-collision-new
! exec grove move sanitized-collision sanitized/collision/new
stderr '✗ directory.*already exists'
exec rmdir ../sanitized-collision-new
exec grove remove sanitized-collision

## Branch Sanitization

# Branch with slashes → sanitized to dashes
exec grove add slash-sanitize
exec grove move slash-sanitize new/with/slashes
stderr 'Renamed slash-sanitize to new/with/slashes'
stderr 'dir: new-with-slashes'
! exists ../slash-sanitize
exists ../new-with-slashes
exec grove remove new-with-slashes

# Multiple slashes → each replaced
exec grove add multi-slash
exec grove move multi-slash release/v1/patch/fix
stderr 'dir: release-v1-patch-fix'
exists ../release-v1-patch-fix
exec grove remove release-v1-patch-fix

## Output Formatting

# Branch != directory name → shows "(dir: Z)"
exec grove add output-test
exec grove move output-test feat/output/test
stderr 'Renamed output-test to'
stderr 'dir: feat-output-test'
exec grove remove feat-output-test

# Branch == directory name → no dir suffix
exec grove add simple-output
exec grove move simple-output simple-renamed
stderr 'Renamed simple-output to simple-renamed'
! stderr 'dir:'
exec grove remove simple-renamed

## Rapid Consecutive Moves

# A→B, B→C both succeed
exec grove add rapid-a
exec grove move rapid-a rapid-b
stderr 'Renamed rapid-a to rapid-b'
exists ../rapid-b
exec grove move rapid-b rapid-c
stderr 'Renamed rapid-b to rapid-c'
exists ../rapid-c
! exists ../rapid-b
exec grove remove rapid-c

## Same Branch Name Validation

# Source and destination are the same → error
! exec grove move feature-branch feature-branch
stderr '✗ source and destination are the same'

## Verify Git State After Move

# Branch actually renamed in git
exec grove add verify-git
exec grove move verify-git verified-branch
exec git -C $WORK/workspace/.bare branch
stdout 'verified-branch'
! stdout 'verify-git'
exec git -C $WORK/workspace/.bare worktree list
stdout 'verified-branch'
stdout 'workspace/verified-branch'
exec grove remove verified-branch

-- README.md --
# Test Repository

-- modified.txt --
# Test Repository
modified

-- staged.txt --
# Test Repository
staged

-- untracked.txt --
untracked

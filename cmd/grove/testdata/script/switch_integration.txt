# grove switch integration tests
# Tests worktree switching with real git state

# Setup workspace with multiple worktrees
mkdir testrepo
exec git init testrepo
cd testrepo
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b feature/auth
exec git checkout -b develop
exec git checkout main
cd ..

mkdir workspace
exec grove clone file://$WORK/testrepo workspace --branches main,develop,feature/auth
cd workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"

## Match by directory name (first priority) → returns path

exec grove switch main
stdout '[/\\\\]workspace[/\\\\]main$'
! stderr .

## Match by branch name (fallback) → returns path

exec grove switch feature/auth
stdout '[/\\\\]workspace[/\\\\]feature-auth$'
! stderr .

## Directory name takes precedence over branch name

# Create ambiguous scenario: dir 'ambiguous' with branch 'other-branch'
exec grove add --name ambiguous other-branch
# 'ambiguous' is a directory, not a branch - should match directory name
exec grove switch ambiguous
stdout '[/\\\\]workspace[/\\\\]ambiguous$'
! stderr .
exec grove remove ambiguous

## Branch with slashes → matches by branch name

exec grove switch feature/auth
stdout '[/\\\\]workspace[/\\\\]feature-auth$'
! stderr .

## Leading/trailing whitespace → trimmed, matches worktree

exec grove switch '  main  '
stdout '[/\\\\]workspace[/\\\\]main$'
! stderr .

## Empty string after trimming → error

! exec grove switch '   '
stderr '✗ worktree not found'

## No match found → error

! exec grove switch nonexistent
stderr '✗ worktree not found: nonexistent'

## Case-sensitive matching → exact match required

! exec grove switch Main
stderr '✗ worktree not found: Main'

! exec grove switch DEVELOP
stderr '✗ worktree not found: DEVELOP'

## Switch to current worktree → succeeds (outputs same path)

cd $WORK/workspace/main
exec grove switch main
stdout '[/\\\\]workspace[/\\\\]main$'
! stderr .

## Detached HEAD worktree → matches by directory name

exec git tag v1.0.0
exec grove add --detach v1.0.0
exec grove switch v1.0.0
stdout '[/\\\\]workspace[/\\\\]v1.0.0$'
! stderr .

## CWD is workspace root → works

cd $WORK/workspace
exec grove switch main
stdout '[/\\\\]workspace[/\\\\]main$'
! stderr .

## CWD inside worktree → works

cd $WORK/workspace/main
exec grove switch develop
stdout '[/\\\\]workspace[/\\\\]develop$'
! stderr .

## CWD in worktree subdirectory → finds workspace

mkdir -p $WORK/workspace/main/src/pkg
cd $WORK/workspace/main/src/pkg
exec grove switch develop
stdout '[/\\\\]workspace[/\\\\]develop$'
! stderr .
cd $WORK/workspace/main

## Path with spaces → correctly output

exec grove add --name 'my worktree' space-branch
exec grove switch 'my worktree'
stdout 'my worktree$'
! stderr .
exec grove remove 'my worktree'

## Locked worktree → switch succeeds

exec git -C $WORK/workspace/.bare worktree lock ../feature-auth --reason 'Testing lock'
exec grove switch feature-auth
stdout '[/\\\\]workspace[/\\\\]feature-auth$'
! stderr .
exec git -C $WORK/workspace/.bare worktree unlock ../feature-auth

## Dirty worktree → switch succeeds

exec sh -c 'echo "modified" >> ../develop/README.md'
exec grove switch develop
stdout '[/\\\\]workspace[/\\\\]develop$'
! stderr .
# Clean up
exec git -C ../develop checkout README.md

## Merge conflict in target → switch succeeds

cd $WORK/workspace/develop
exec git checkout -b merge-source
exec sh -c 'echo "source" > conflict.txt'
exec git add conflict.txt
exec git commit -m 'source commit'
exec git checkout develop
exec sh -c 'echo "target" > conflict.txt'
exec git add conflict.txt
exec git commit -m 'target commit'
! exec git merge merge-source
exec git status
stdout 'Unmerged'
cd $WORK/workspace/main
# Switch to worktree with merge conflict should still work
exec grove switch develop
stdout '[/\\\\]workspace[/\\\\]develop$'
! stderr .
# Clean up
exec git -C ../develop merge --abort

## Shell completion: suggests all worktrees except current

cd $WORK/workspace/main
exec grove __complete switch ''
stdout 'feature-auth'
stdout 'develop'
stdout 'v1.0.0'
! stdout '^main$'

## Shell completion: from worktree subdirectory → still excludes current

cd $WORK/workspace/main/src/pkg
exec grove __complete switch ''
! stdout '^main$'
stdout 'develop'
cd $WORK/workspace/main

## Shell completion: already has arg → no more suggestions

exec grove __complete switch main ''
! stdout 'main'
! stdout 'develop'

## Not in workspace → error

mkdir $WORK/outside
cd $WORK/outside
! exec grove switch main
stderr '✗ not in a grove workspace'

## Shell init - sh (used for bash/zsh/sh)
# Generates a POSIX-compatible shell function that wraps `grove switch`
# and cds to the output path. Must not use bash-specific syntax like [[ ]].

cd $WORK/workspace/main
exec grove switch shell-init --shell sh
stdout 'grove\(\)'
stdout 'command grove switch'
stdout 'case "\$1" in'
# POSIX shell uses [ ] for tests, not bash's [[ ]] which is non-portable
! stdout '\[\['
stdout 'grove add'
stdout '\-\-switch'
! stderr .

## Shell init - bash outputs POSIX script
# Bash gets the same POSIX script as sh for maximum compatibility

exec grove switch shell-init --shell bash
stdout 'grove\(\)'
stdout 'case "\$1" in'
# POSIX shell uses [ ] for tests, not bash's [[ ]] which is non-portable
! stdout '\[\['
! stderr .

## Shell init - fish
# Fish shell uses different function syntax and variable scoping

exec grove switch shell-init --shell fish
stdout 'function grove'
stdout 'command grove switch'
stdout 'cd "\$target"'
stdout 'set -l target'
! stderr .

## Shell init - PowerShell
# PowerShell uses different syntax and requires .exe suffix on Windows

exec grove switch shell-init --shell powershell
stdout 'grove.exe switch'
stdout 'Set-Location'
! stderr .

## Shell init - unsupported shell

! exec grove switch shell-init --shell tcsh
stderr '✗ unsupported shell: tcsh'

-- README.md --
# Test

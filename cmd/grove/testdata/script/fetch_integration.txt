# grove fetch integration tests
# Tests fetching from remotes with change detection

# Setup: Create origin repository
mkdir origin
exec git init --bare origin

# Create a repo to push initial content
mkdir source
exec git init source
cd source
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
exec git remote add origin ../origin
exec git push -u origin main
cd ..

# Clone into grove workspace
mkdir workspace
exec grove clone file://$WORK/origin workspace
cd workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"

## Test: Fetch with no changes

exec grove fetch
stderr 'All remotes up to date'

## Test: Detect new branch

# Create new branch on origin
cd $WORK/source
exec git checkout -b feature/new-branch
exec git push origin feature/new-branch
exec git checkout main

# Fetch from workspace and detect new branch
cd $WORK/workspace/main
exec grove fetch
stdout 'origin:'
stdout '\+ feature/new-branch'

# Subsequent fetch should show no changes
exec grove fetch
stderr 'All remotes up to date'

## Test: Detect updated branch

# Add commit to main on origin
cd $WORK/source
cp $WORK/readme-update.md README.md
exec git add .
exec git commit -m 'update main'
exec git push origin main

# Fetch from workspace and detect update
cd $WORK/workspace/main
exec grove fetch
stdout 'origin:'
stdout '\* main'
stdout '\+1 commit'

## Test: Detect pruned branch

# Delete the feature branch on origin
cd $WORK/source
exec git push origin --delete feature/new-branch

# Fetch from workspace and detect pruned ref
cd $WORK/workspace/main
exec grove fetch
stdout 'origin:'
stdout '- feature/new-branch'
stdout 'deleted on remote'

## Test: Works from subdirectory

mkdir subdir
cd subdir
exec grove fetch
stderr 'All remotes up to date'

## Test: Works from workspace root

cd $WORK/workspace
exec grove fetch
stderr 'All remotes up to date'

## Test: Multiple commits shown with count

cd $WORK/source
cp $WORK/readme-line1.md README.md
exec git add .
exec git commit -m 'commit 1'
cp $WORK/readme-line2.md README.md
exec git add .
exec git commit -m 'commit 2'
cp $WORK/readme-line3.md README.md
exec git add .
exec git commit -m 'commit 3'
exec git push origin main

cd $WORK/workspace/main
exec grove fetch
stdout 'origin:'
stdout '\* main'
stdout '\+3 commits'

## Test: Multiple remotes

# Add a second remote (upstream) pointing to same origin
cd $WORK/workspace/main
exec git remote add upstream file://$WORK/origin

# First fetch - upstream is new so shows new branches, origin has no changes
exec grove fetch
stdout 'upstream:'
stdout '\+ main'
! stdout 'origin:'

# Make a change on origin
cd $WORK/source
cp $WORK/readme-multi.md README.md
exec git add .
exec git commit -m 'multi-remote test'
exec git push origin main

# Now both remotes should show changes
cd $WORK/workspace/main
exec grove fetch
stdout 'origin:'
stdout 'upstream:'

# Clean up for subsequent tests
exec git remote remove upstream

## Test: Force-push detection (orphan history rewrite)

# Create orphan branch with no common ancestor
cd $WORK/source
exec git checkout --orphan orphan-test
exec git rm -rf .
cp $WORK/orphan1.txt orphan.txt
exec git add .
exec git commit -m 'orphan commit 1'
exec git push origin orphan-test

# Fetch to get the branch
cd $WORK/workspace/main
exec grove fetch
stdout '\+ orphan-test'

# Create completely different orphan history (no common ancestor with previous)
cd $WORK/source
exec git checkout --orphan temp-orphan
exec git rm -rf .
cp $WORK/orphan2.txt orphan.txt
exec git add .
exec git commit -m 'orphan commit 2'
exec git branch -D orphan-test
exec git branch -m orphan-test
exec git push --force origin orphan-test

# Fetch detects the rewrite - shows commit count since histories can be measured
# Note: "force-pushed" only appears when commit count is undeterminable (e.g., git error)
cd $WORK/workspace/main
exec grove fetch
stdout 'origin:'
stdout '\* orphan-test'

# Return to main for subsequent tests
cd $WORK/source
exec git checkout main

## Test: Backward commit count (rollback)

# Add multiple commits to a branch
cd $WORK/source
exec git checkout main
cp $WORK/readme-a.md README.md
exec git add .
exec git commit -m 'commit a'
cp $WORK/readme-b.md README.md
exec git add .
exec git commit -m 'commit b'
exec git push origin main

# Fetch to sync
cd $WORK/workspace/main
exec grove fetch
stdout '\+2 commits'

# Now rollback on origin (force push to earlier commit)
cd $WORK/source
exec git reset --hard HEAD~2
exec git push --force origin main

# Fetch should show negative commit count
cd $WORK/workspace/main
exec grove fetch
stdout 'origin:'
stdout '\* main'
stdout '-2 commits'

## Test: Unreachable remote error

# First make a change on origin so we can verify it still fetches
cd $WORK/source
cp $WORK/readme-error.md README.md
exec git add .
exec git commit -m 'error test commit'
exec git push origin main

# Add a remote with invalid URL
cd $WORK/workspace/main
exec git remote add broken file:///nonexistent/path

# Fetch should report error but continue with other remotes
! exec grove fetch
stderr 'broken:'
stdout 'origin:'

# Clean up
exec git remote remove broken

## Test: No remotes configured

cd $WORK
mkdir empty-ws
exec grove init new empty-ws
cd empty-ws
exec grove add main
cd main
exec grove fetch
stderr 'No remotes configured'

-- README.md --
# Test

-- readme-update.md --
# Test
update

-- readme-line1.md --
# Test
update
line1

-- readme-line2.md --
# Test
update
line1
line2

-- readme-line3.md --
# Test
update
line1
line2
line3

-- readme-multi.md --
# Test
update
line1
line2
line3
multi

-- readme-a.md --
# Test
update
line1
line2
line3
multi
a

-- readme-b.md --
# Test
update
line1
line2
line3
multi
a
b

-- readme-error.md --
# Test
update
line1
line2
line3
multi
error test

-- orphan1.txt --
orphan1

-- orphan2.txt --
orphan2

# grove move integration tests
# Tests worktree renaming with real git state

# Setup workspace with multiple worktrees
mkdir testrepo
exec git init testrepo
cd testrepo
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b feature-branch
exec git checkout -b develop
exec git checkout main
cd ..

mkdir workspace
exec grove clone file://$WORK/testrepo workspace
cd workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"

# Create worktrees for testing
exec grove add feature-branch
exec grove add develop

## Worktree Lookup

# Match by directory name (exact) → finds worktree
exec grove add to-move-dir
exists ../to-move-dir
exec grove move to-move-dir renamed-branch
stderr 'Renamed to-move-dir to renamed-branch'
! exists ../to-move-dir
exists ../renamed-branch

# Match by branch name (fallback) → finds worktree
exec grove add feature/slash-lookup
exists ../feature-slash-lookup
exec grove move feature/slash-lookup feature/renamed
stderr 'Renamed feature/slash-lookup to feature/renamed'
! exists ../feature-slash-lookup
exists ../feature-renamed

# Directory name takes precedence over branch name
exec grove add --name dir-precedence some-branch-name
exists ../dir-precedence
exec grove move dir-precedence new-dir-precedence
stderr 'Renamed dir-precedence to new-dir-precedence'
! exists ../dir-precedence
exists ../new-dir-precedence

# Worktree not found → error
! exec grove move nonexistent-worktree new-name
stderr 'worktree not found'

## Current Worktree Protection

# CWD is target worktree → error
exec grove add cwd-test
cd ../cwd-test
! exec grove move cwd-test cwd-renamed
stderr 'cannot rename current worktree'
cd ../main

# CWD is subdirectory of target → error
exec grove add subdir-cwd-test
mkdir ../subdir-cwd-test/deep/nested
cd ../subdir-cwd-test/deep/nested
! exec grove move subdir-cwd-test subdir-renamed
stderr 'cannot rename current worktree'
cd $WORK/workspace/main

# CWD is different worktree → allowed
exec grove move subdir-cwd-test moved-from-main
stderr 'Renamed subdir-cwd-test to moved-from-main'
exists ../moved-from-main

# CWD is workspace root → allowed
cd $WORK/workspace
exec grove move cwd-test moved-from-root
stderr 'Renamed cwd-test to moved-from-root'
exists moved-from-root
cd main

## Branch Name Validation

# New branch already exists locally → error
exec grove add existing-local
! exec grove move existing-local develop
stderr 'branch.*already exists'
exec grove remove existing-local

# New branch exists on remote → error (via refs)
# Create a branch in the origin repo
cd $WORK/testrepo
exec git checkout -b remote-only-branch
exec git checkout main
cd $WORK/workspace/main
# Fetch with refspec to create remote tracking branch
exec git fetch origin remote-only-branch:refs/remotes/origin/remote-only-branch
exec grove add local-to-remote
! exec grove move local-to-remote remote-only-branch
stderr 'branch.*already exists'
exec grove remove local-to-remote

## Dirty State Check

# Modified tracked files → error
exec grove add dirty-modified
exec sh -c 'echo "modified" >> ../dirty-modified/README.md'
! exec grove move dirty-modified dirty-renamed
stderr 'uncommitted changes'
# Force remove to clean up
exec grove remove -f dirty-modified

# Staged but not committed → error
exec grove add dirty-staged
exec sh -c 'echo "staged" >> ../dirty-staged/README.md'
exec git -C ../dirty-staged add README.md
! exec grove move dirty-staged staged-renamed
stderr 'uncommitted changes'
# Force remove to clean up
exec grove remove -f dirty-staged

# Untracked files → also treated as dirty (consistent with remove)
exec grove add dirty-untracked
exec sh -c 'echo "untracked" > ../dirty-untracked/untracked.txt'
! exec grove move dirty-untracked untracked-renamed
stderr 'uncommitted changes'
exec grove remove -f dirty-untracked

# Clean worktree → allowed
exec grove add clean-test
exec grove move clean-test clean-renamed
stderr 'Renamed clean-test to clean-renamed'
exec grove remove clean-renamed

## Locked Worktree Check

# Worktree is locked → error
exec grove add locked-test
exec grove lock locked-test
! exec grove move locked-test locked-renamed
stderr 'worktree is locked'
exec grove unlock locked-test
exec grove remove locked-test

# Unlocked worktree → allowed
exec grove add unlocked-test
exec grove move unlocked-test unlocked-renamed
stderr 'Renamed unlocked-test to unlocked-renamed'
exec grove remove unlocked-renamed

## Directory Validation

# New directory already exists → error
exec grove add dir-exists-test
mkdir ../blocking-dir
! exec grove move dir-exists-test blocking-dir
stderr 'directory.*already exists'
exec rmdir ../blocking-dir
exec grove remove dir-exists-test

# Sanitized name causes collision → error
exec grove add sanitized-collision
mkdir ../sanitized-collision-new
! exec grove move sanitized-collision sanitized/collision/new
stderr 'directory.*already exists'
exec rmdir ../sanitized-collision-new
exec grove remove sanitized-collision

## Branch Sanitization

# Branch with slashes → sanitized to dashes
exec grove add slash-sanitize
exec grove move slash-sanitize new/with/slashes
stderr 'Renamed slash-sanitize to new/with/slashes'
stderr 'dir: new-with-slashes'
! exists ../slash-sanitize
exists ../new-with-slashes
exec grove remove new-with-slashes

# Multiple slashes → each replaced
exec grove add multi-slash
exec grove move multi-slash release/v1/patch/fix
stderr 'dir: release-v1-patch-fix'
exists ../release-v1-patch-fix
exec grove remove release-v1-patch-fix

## Output Formatting

# Branch != directory name → shows "(dir: Z)"
exec grove add output-test
exec grove move output-test feat/output/test
stderr 'Renamed output-test to'
stderr 'dir: feat-output-test'
exec grove remove feat-output-test

# Branch == directory name → no dir suffix
exec grove add simple-output
exec grove move simple-output simple-renamed
stderr 'Renamed simple-output to simple-renamed'
! stderr 'dir:'
exec grove remove simple-renamed

## Rapid Consecutive Moves

# A→B, B→C both succeed
exec grove add rapid-a
exec grove move rapid-a rapid-b
stderr 'Renamed rapid-a to rapid-b'
exists ../rapid-b
exec grove move rapid-b rapid-c
stderr 'Renamed rapid-b to rapid-c'
exists ../rapid-c
! exists ../rapid-b
exec grove remove rapid-c

## Same Branch Name Validation

# Source and destination are the same → error
! exec grove move feature-branch feature-branch
stderr 'source and destination are the same'

## Verify Git State After Move

# Branch actually renamed in git
exec grove add verify-git
exec grove move verify-git verified-branch
exec git -C $WORK/workspace/.bare branch
stdout 'verified-branch'
! stdout 'verify-git'
# Worktree path updated in git registry
exec git -C $WORK/workspace/.bare worktree list
stdout 'verified-branch'
stdout 'workspace/verified-branch'
exec grove remove verified-branch

-- README.md --
# Test Repository

# grove prune integration tests
# Tests worktree pruning with real git state

# Setup: Create source repository with branches
mkdir testrepo
exec git init testrepo
cd testrepo
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b feature-to-delete
exec git checkout -b feature-dirty
exec git checkout main
cd ..

# Create grove workspace with --branches to set up tracking
mkdir workspace
exec grove clone file://$WORK/testrepo workspace --branches main,feature-to-delete,feature-dirty

# Configure bare repo to have proper remote tracking refs
# By default, bare clone maps refs/heads/* directly, we need origin/* refs
cd $WORK/workspace/.bare
exec git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'
exec git fetch origin

# Configure git user and set up upstream tracking for each worktree
cd $WORK/workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/main main

cd $WORK/workspace/feature-to-delete
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-to-delete feature-to-delete

cd $WORK/workspace/feature-dirty
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-dirty feature-dirty

## Success: No stale worktrees initially
cd $WORK/workspace/main
exec grove prune
stderr 'No worktrees to prune'

## Success: Detect gone worktree
# Delete branch on "remote" (source repo)
exec git -C $WORK/testrepo branch -D feature-to-delete

# Run prune - should detect gone worktree after fetching
exec grove prune
stderr 'Would prune 1 worktree'
stderr 'feature-to-delete'
stderr 'Run with --commit to remove'

# Worktree should still exist (dry-run)
exists $WORK/workspace/feature-to-delete

## Success: --commit removes worktree
exec grove prune --commit
stderr 'Pruned 1 worktree'
stderr 'feature-to-delete'

# Worktree should be gone now
! exists $WORK/workspace/feature-to-delete

## Skipped: Dirty worktree
# Make feature-dirty worktree dirty
cp $WORK/README.md $WORK/workspace/feature-dirty/dirty.txt

# Delete branch on "remote"
exec git -C $WORK/testrepo branch -D feature-dirty

# Prune should show it as dirty (will be skipped)
exec grove prune
stderr 'Would skip 1 worktree'
stderr 'feature-dirty'
stderr 'dirty, use --force'

# --commit should skip dirty worktree
exec grove prune --commit
stderr 'Skipped 1 worktree'
stderr 'feature-dirty'
stderr 'dirty, use --force'

# Worktree should still exist
exists $WORK/workspace/feature-dirty

## Success: --force removes dirty worktree
exec grove prune --commit --force
stderr 'Pruned 1 worktree'
stderr 'feature-dirty'

# Worktree should be gone now
! exists $WORK/workspace/feature-dirty

## Skipped: Current worktree protected
exec git -C $WORK/testrepo checkout -b feature-current
exec git -C $WORK/testrepo checkout main

# Fetch the new branch and create a worktree
cd $WORK/workspace/.bare
exec git fetch origin
cd $WORK/workspace/main
exec grove add feature-current

cd $WORK/workspace/feature-current
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-current feature-current

# Delete branch on "remote"
exec git -C $WORK/testrepo branch -D feature-current

# Prune from inside the worktree should show it as current (will be skipped)
exec grove prune
stderr 'Would skip 1 worktree'
stderr 'feature-current'
stderr 'current worktree'

# --commit should skip current worktree
exec grove prune --commit
stderr 'Skipped 1 worktree'
stderr 'feature-current'
stderr 'current worktree'

# Worktree should still exist
exists $WORK/workspace/feature-current

## Skipped: Current worktree from subdirectory
# Create subdirectory inside the worktree
mkdir -p $WORK/workspace/feature-current/src/components
cd $WORK/workspace/feature-current/src/components

# Prune from inside subdirectory should still show it as current (will be skipped)
exec grove prune
stderr 'Would skip 1 worktree'
stderr 'feature-current'
stderr 'current worktree'

# --commit from subdirectory should still skip current worktree
exec grove prune --commit
stderr 'Skipped 1 worktree'
stderr 'feature-current'
stderr 'current worktree'

# Worktree should still exist
exists $WORK/workspace/feature-current

## Skipped: Locked worktree
# Go back to main first and clean up any remaining candidates
cd $WORK/workspace/main
# First clean up feature-current from previous test (it's no longer current since we're in main)
exec grove prune --commit --force

# Create new branch and worktree for lock test
exec git -C $WORK/testrepo checkout -b feature-locked
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin
exec grove add feature-locked
cd $WORK/workspace/feature-locked
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-locked feature-locked

# Lock the worktree
exec git -C $WORK/workspace/.bare worktree lock ../feature-locked --reason 'Important work'

# Delete branch on remote
exec git -C $WORK/testrepo branch -D feature-locked

cd $WORK/workspace/main
exec grove prune
stderr 'Would skip 1 worktree'
stderr 'feature-locked'
stderr 'locked, use --force'

# Worktree still exists
exists $WORK/workspace/feature-locked

## Success: Locked worktree with --force
# Note: git worktree remove --force only removes dirty worktrees, not locked ones
# For locked worktrees, git needs --force --force OR unlock first
# Grove's --force doesn't pass double-force to git, so we unlock manually
exec git -C $WORK/workspace/.bare worktree unlock ../feature-locked
exec grove prune --commit --force
stderr 'Pruned 1 worktree'
stderr 'feature-locked'
! exists $WORK/workspace/feature-locked

## Edge case: Unpushed commits with gone upstream
# Note: When upstream is deleted, Ahead=0 because there's nothing to compare to
# So unpushed commits on a gone branch are prunable (design limitation)
# Create new branch and worktree for unpushed test
exec git -C $WORK/testrepo checkout -b feature-unpushed
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin
exec grove add feature-unpushed
cd $WORK/workspace/feature-unpushed
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-unpushed feature-unpushed

# Create local commit (unpushed)
exec sh -c 'echo "unpushed change" > unpushed.txt'
exec git add unpushed.txt
exec git commit -m 'unpushed commit'

# Delete branch on remote - this makes Ahead=0 (no upstream to compare)
exec git -C $WORK/testrepo branch -D feature-unpushed

cd $WORK/workspace/main
# Note: Shows as "Would prune" not "Would skip" because Ahead can't be computed
exec grove prune
stderr 'Would prune 1 worktree'
stderr 'feature-unpushed'

# Clean up
exec grove prune --commit
stderr 'Pruned 1 worktree'
! exists $WORK/workspace/feature-unpushed

## Success: Multiple gone worktrees listed
# Create multiple branches for multi-prune test
exec git -C $WORK/testrepo checkout -b feature-multi-1
exec git -C $WORK/testrepo checkout -b feature-multi-2
exec git -C $WORK/testrepo checkout -b feature-multi-3
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-multi-1
exec grove add feature-multi-2
exec grove add feature-multi-3

cd $WORK/workspace/feature-multi-1
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-multi-1 feature-multi-1

cd $WORK/workspace/feature-multi-2
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-multi-2 feature-multi-2

cd $WORK/workspace/feature-multi-3
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-multi-3 feature-multi-3

# Delete all branches on remote
exec git -C $WORK/testrepo branch -D feature-multi-1
exec git -C $WORK/testrepo branch -D feature-multi-2
exec git -C $WORK/testrepo branch -D feature-multi-3

cd $WORK/workspace/main
exec grove prune
stderr 'Would prune 3 worktrees'
stderr 'feature-multi-1'
stderr 'feature-multi-2'
stderr 'feature-multi-3'

## Success: Multiple worktrees pruned
exec grove prune --commit
stderr 'Pruned 3 worktrees'
stderr 'feature-multi-1'
stderr 'feature-multi-2'
stderr 'feature-multi-3'
! exists $WORK/workspace/feature-multi-1
! exists $WORK/workspace/feature-multi-2
! exists $WORK/workspace/feature-multi-3

## Success: Mixed output (prunable + skipped)
# Create two branches - one clean, one dirty
exec git -C $WORK/testrepo checkout -b feature-clean
exec git -C $WORK/testrepo checkout -b feature-dirty-mix
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-clean
exec grove add feature-dirty-mix

cd $WORK/workspace/feature-clean
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-clean feature-clean

cd $WORK/workspace/feature-dirty-mix
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-dirty-mix feature-dirty-mix
# Make dirty
exec sh -c 'echo "dirty" > dirty-file.txt'

# Delete both branches on remote
exec git -C $WORK/testrepo branch -D feature-clean
exec git -C $WORK/testrepo branch -D feature-dirty-mix

cd $WORK/workspace/main
exec grove prune
stderr 'Would prune 1 worktree'
stderr 'feature-clean'
stderr 'Would skip 1 worktree'
stderr 'feature-dirty-mix'
stderr 'dirty, use --force'

## Success: Commit mode with mixed
exec grove prune --commit
stderr 'Pruned 1 worktree'
stderr 'feature-clean'
stderr 'Skipped 1 worktree'
stderr 'feature-dirty-mix'
! exists $WORK/workspace/feature-clean
exists $WORK/workspace/feature-dirty-mix

# Cleanup dirty worktree
exec grove prune --commit --force
! exists $WORK/workspace/feature-dirty-mix

## Success: No candidates message
exec grove prune --commit
stderr 'No worktrees to remove'

## Skipped: Current takes priority over dirty
# Create worktree, make dirty, go into it
exec git -C $WORK/testrepo checkout -b feature-priority
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin
exec grove add feature-priority
cd $WORK/workspace/feature-priority
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-priority feature-priority
# Make dirty
exec sh -c 'echo "dirty" > dirty-file.txt'
# Delete remote
exec git -C $WORK/testrepo branch -D feature-priority

# From inside the worktree (current), skip reason should be "current", not "dirty"
exec grove prune
stderr 'Would skip 1 worktree'
stderr 'current worktree'
! stdout 'dirty'

# Cleanup - go back to main and force remove
cd $WORK/workspace/main
exec grove prune --commit --force

## Success: --stale detects old worktrees
# Create branch with old commit (use GIT_COMMITTER_DATE to backdate)
exec git -C $WORK/testrepo checkout -b feature-stale
exec sh -c 'cd $WORK/testrepo && GIT_COMMITTER_DATE="2024-01-01T00:00:00" GIT_AUTHOR_DATE="2024-01-01T00:00:00" git commit --allow-empty -m "old commit"'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

# Create worktree for old branch
exec grove add feature-stale
cd $WORK/workspace/feature-stale
exec git config user.name "Test"
exec git config user.email "test@example.com"

# Without --stale, not detected (branch still has upstream, not gone)
cd $WORK/workspace/main
exec grove prune
stderr 'No worktrees to prune'

# With --stale 30d, detected as stale candidate
exec grove prune --stale 30d
stderr 'Would prune 1 worktree'
stderr 'feature-stale'
# Age should be shown in output (date is ~2 years old, shows "1 year ago" or "2 years ago")
stderr 'year.* ago'
stderr 'Run with --commit to remove'

# Actually remove with --commit
exec grove prune --stale 30d --commit
stderr 'Pruned 1 worktree'
stderr 'feature-stale'
! exists $WORK/workspace/feature-stale

## Success: --stale ignores recent worktrees
# Create fresh branch (commit is recent)
exec git -C $WORK/testrepo checkout -b feature-fresh
exec sh -c 'cd $WORK/testrepo && git commit --allow-empty -m "fresh commit"'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-fresh
cd $WORK/workspace/feature-fresh
exec git config user.name "Test"
exec git config user.email "test@example.com"

cd $WORK/workspace/main
# With --stale 30d, should NOT detect feature-fresh (it's new)
exec grove prune --stale 30d
stderr 'No worktrees to prune'

# Cleanup
exec grove remove feature-fresh

## Success: --merged detects merged branches
# Create feature branch with a commit
exec git -C $WORK/testrepo checkout -b feature-merged
exec sh -c 'echo "feature content" > $WORK/testrepo/merged-feature.txt'
exec git -C $WORK/testrepo add merged-feature.txt
exec git -C $WORK/testrepo commit -m 'feature commit'

# Merge into main (use --no-ff to force a merge commit, not fast-forward)
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/testrepo merge --no-ff feature-merged -m 'merge feature'
exec git -C $WORK/workspace/.bare fetch origin

# Update main worktree to match origin/main (so merge detection works correctly)
exec git -C $WORK/workspace/main pull

# Create worktree for merged branch
exec grove add feature-merged
cd $WORK/workspace/feature-merged
exec git config user.name "Test"
exec git config user.email "test@example.com"

# Without --merged, not detected
cd $WORK/workspace/main
exec grove prune
stderr 'No worktrees to prune'

# With --merged, detected as merged candidate
exec grove prune --merged
stderr 'Would prune 1 worktree'
stderr 'feature-merged'

# Actually remove
exec grove prune --merged --commit
stderr 'Pruned 1 worktree'
stderr 'feature-merged'
! exists $WORK/workspace/feature-merged

## Success: --merged detects squash merged branches
# Create feature branch with commit
exec git -C $WORK/testrepo checkout -b feature-squashed
exec sh -c 'echo "squash content" > $WORK/testrepo/squash-feature.txt'
exec git -C $WORK/testrepo add squash-feature.txt
exec git -C $WORK/testrepo commit -m 'squash commit'

# Squash merge into main
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/testrepo merge --squash feature-squashed
exec git -C $WORK/testrepo commit -m 'squashed feature'
exec git -C $WORK/workspace/.bare fetch origin

# Update main worktree to include the squash-merged commit
exec git -C $WORK/workspace/main pull

# Create worktree for squashed branch
exec grove add feature-squashed
cd $WORK/workspace/feature-squashed
exec git config user.name "Test"
exec git config user.email "test@example.com"

cd $WORK/workspace/main
# With --merged, should detect squash-merged branch via patch-id comparison
exec grove prune --merged
stderr 'Would prune 1 worktree'
stderr 'feature-squashed'

# Cleanup
exec grove prune --merged --commit
! exists $WORK/workspace/feature-squashed

## Success: --merged ignores unmerged branches
# Create unmerged branch
exec git -C $WORK/testrepo checkout -b feature-unmerged
exec sh -c 'echo "unmerged content" > $WORK/testrepo/unmerged-feature.txt'
exec git -C $WORK/testrepo add unmerged-feature.txt
exec git -C $WORK/testrepo commit -m 'unmerged commit'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-unmerged
cd $WORK/workspace/feature-unmerged
exec git config user.name "Test"
exec git config user.email "test@example.com"

cd $WORK/workspace/main
# With --merged, should NOT detect feature-unmerged
exec grove prune --merged
stderr 'No worktrees to prune'

# Cleanup
exec grove remove feature-unmerged

## Success: --detached detects detached worktrees
# Create a branch and worktree, then detach HEAD
exec git -C $WORK/testrepo checkout -b feature-detached
exec sh -c 'echo "detached content" > $WORK/testrepo/detached-feature.txt'
exec git -C $WORK/testrepo add detached-feature.txt
exec git -C $WORK/testrepo commit -m 'detached commit'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-detached
cd $WORK/workspace/feature-detached
exec git config user.name "Test"
exec git config user.email "test@example.com"

# Detach HEAD by checking out the commit directly
exec git checkout HEAD~0

cd $WORK/workspace/main
# Without --detached, not detected
exec grove prune
stderr 'No worktrees to prune'

# With --detached, detected as detached candidate
exec grove prune --detached
stderr 'Would prune 1 worktree'
# Should show directory name, not "(detached)"
stderr 'feature-detached'
! stderr '\(detached\)'
stderr 'Run with --commit to remove'

# Actually remove with --commit
exec grove prune --detached --commit
stderr 'Pruned 1 worktree'
stderr 'feature-detached'
! exists $WORK/workspace/feature-detached

## Skipped: Dirty detached worktree
# Create another detached worktree and make it dirty
exec git -C $WORK/testrepo checkout -b feature-detached-dirty
exec sh -c 'echo "dirty detached" > $WORK/testrepo/dirty-detached.txt'
exec git -C $WORK/testrepo add dirty-detached.txt
exec git -C $WORK/testrepo commit -m 'dirty detached commit'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-detached-dirty
cd $WORK/workspace/feature-detached-dirty
exec git config user.name "Test"
exec git config user.email "test@example.com"

# Detach HEAD
exec git checkout HEAD~0
# Make dirty
exec sh -c 'echo "dirty" > dirty-file.txt'

cd $WORK/workspace/main
# With --detached, should show as skipped (dirty)
exec grove prune --detached
stderr 'Would skip 1 worktree'
stderr 'feature-detached-dirty'
stderr 'dirty, use --force'

# --commit should skip dirty detached worktree
exec grove prune --detached --commit
stderr 'Skipped 1 worktree'
stderr 'feature-detached-dirty'
stderr 'dirty, use --force'

# Worktree should still exist
exists $WORK/workspace/feature-detached-dirty

# --force should remove dirty detached worktree
exec grove prune --detached --commit --force
stderr 'Pruned 1 worktree'
stderr 'feature-detached-dirty'
! exists $WORK/workspace/feature-detached-dirty

## Detached worktree with deleted remote branch
# Create a branch, make worktree, detach, then delete remote branch
exec git -C $WORK/testrepo checkout -b feature-gone-detached
exec sh -c 'echo "gone detached" > $WORK/testrepo/gone-detached.txt'
exec git -C $WORK/testrepo add gone-detached.txt
exec git -C $WORK/testrepo commit -m 'gone detached commit'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-gone-detached
cd $WORK/workspace/feature-gone-detached
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-gone-detached feature-gone-detached

# Detach HEAD
exec git checkout HEAD~0

# Delete branch on remote
exec git -C $WORK/testrepo branch -D feature-gone-detached

cd $WORK/workspace/main
# Detached worktrees have NoUpstream=true, so Gone check doesn't apply
# With --detached, detected as detached candidate
exec grove prune --detached
stderr 'Would prune 1 worktree'
stderr 'feature-gone-detached'

# Cleanup
exec grove prune --detached --commit
! exists $WORK/workspace/feature-gone-detached

## Priority: Gone takes priority over stale
# Create old branch and then delete from remote
exec git -C $WORK/testrepo checkout -b feature-gone-stale
exec sh -c 'cd $WORK/testrepo && GIT_COMMITTER_DATE="2024-01-01T00:00:00" GIT_AUTHOR_DATE="2024-01-01T00:00:00" git commit --allow-empty -m "old gone commit"'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/workspace/.bare fetch origin

exec grove add feature-gone-stale
cd $WORK/workspace/feature-gone-stale
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git branch --set-upstream-to=origin/feature-gone-stale feature-gone-stale

# Delete from remote - now both gone AND stale
exec git -C $WORK/testrepo branch -D feature-gone-stale

cd $WORK/workspace/main
# With --stale, branch should be listed once (as gone, not as both gone and stale)
exec grove prune --stale 30d
stderr 'Would prune 1 worktree'
stderr 'feature-gone-stale'

# Cleanup
exec grove prune --commit
! exists $WORK/workspace/feature-gone-stale

## Priority: Merged takes priority over stale
# Create old branch that's also merged
exec git -C $WORK/testrepo checkout -b feature-merged-stale
exec sh -c 'cd $WORK/testrepo && GIT_COMMITTER_DATE="2024-01-01T00:00:00" GIT_AUTHOR_DATE="2024-01-01T00:00:00" git commit --allow-empty -m "old merged commit"'
exec git -C $WORK/testrepo checkout main
exec git -C $WORK/testrepo merge --no-ff feature-merged-stale -m 'merge old feature'
exec git -C $WORK/workspace/.bare fetch origin

# Update main worktree to include the merge
exec git -C $WORK/workspace/main pull

exec grove add feature-merged-stale
cd $WORK/workspace/feature-merged-stale
exec git config user.name "Test"
exec git config user.email "test@example.com"

cd $WORK/workspace/main
# With both --merged and --stale, branch should be listed once (as merged)
exec grove prune --merged --stale 30d
stderr 'Would prune 1 worktree'
stderr 'feature-merged-stale'

# Cleanup
exec grove prune --merged --commit
! exists $WORK/workspace/feature-merged-stale

## Error: Not in workspace
cd /tmp
! exec grove prune
stderr '^âœ— not in a grove workspace'

-- README.md --
# Test

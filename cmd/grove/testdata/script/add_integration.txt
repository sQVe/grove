# grove add integration tests
# Tests worktree creation with real git state

# Setup: Create workspace via clone
mkdir testrepo
exec git init testrepo
cd testrepo
exec git config user.name "Test"
exec git config user.email "test@example.com"
exec git config commit.gpgsign false
cp ../README.md .
exec git add .
exec git commit -m 'initial commit'
exec git checkout -b existing-branch
exec git checkout main
cd ..

mkdir workspace
exec grove clone file://$WORK/testrepo workspace
cd workspace/main
exec git config user.name "Test"
exec git config user.email "test@example.com"

## Success: Add existing branch

exec grove add existing-branch
stdout 'Created worktree at .*/existing-branch'
! stderr .
exists ../existing-branch
# Verify worktree is on correct branch
exec git -C ../existing-branch rev-parse --abbrev-ref HEAD
stdout '^existing-branch$'

## Success: Add new branch

exec grove add feature/new-thing
stdout 'Created worktree at .*/feature-new-thing'
! stderr .
exists ../feature-new-thing
# Verify worktree is on correct branch
exec git -C ../feature-new-thing rev-parse --abbrev-ref HEAD
stdout '^feature/new-thing$'

## Error: Branch already has worktree

! exec grove add existing-branch
stderr 'worktree already exists for branch'

## Error: Directory already exists

mkdir ../test-dir
! exec grove add test-dir
stderr 'directory already exists:.*test-dir'

## Success: --switch outputs path only

cd $WORK/workspace/main
exec grove add --switch feature/switch-test
stdout '^.*/feature-switch-test$'
! stdout 'Created worktree'
! stderr .
exists ../feature-switch-test

## Success: -s shorthand outputs path only

exec grove add -s feature/short-flag
stdout '^.*/feature-short-flag$'
! stdout 'Created worktree'
! stderr .
exists ../feature-short-flag

## Success: --base creates branch from specified base

cd $WORK/workspace/main
exec grove add --base existing-branch feature/from-existing
stdout 'Created worktree at .*/feature-from-existing'
! stderr .
exists ../feature-from-existing
# Verify new branch was created
exec git -C ../feature-from-existing rev-parse --abbrev-ref HEAD
stdout '^feature/from-existing$'
# Verify branch started from correct base (same commit as existing-branch)
exec git -C ../feature-from-existing rev-parse HEAD
cp stdout head_commit.txt
exec git -C ../existing-branch rev-parse HEAD
cmp stdout head_commit.txt

## Error: --base with nonexistent branch

! exec grove add --base nonexistent-branch feature/from-nonexistent
stderr 'does not exist'

## Success: --detach creates detached HEAD worktree

# Create a tag to use for detached HEAD
exec git -C $WORK/testrepo tag v1.0.0
cd $WORK/workspace/.bare
exec git fetch --tags
cd $WORK/workspace/main
exec grove add --detach v1.0.0
stdout 'Created detached worktree at .*/v1.0.0'
! stderr .
exists ../v1.0.0
# Verify worktree is in detached HEAD state
exec git -C ../v1.0.0 rev-parse --abbrev-ref HEAD
stdout '^HEAD$'

## Success: --detach with commit SHA

# Use HEAD as the commit reference - it resolves to current commit SHA
exec grove add --detach --name detached-sha HEAD
stdout 'Created detached worktree at .*/detached-sha'
! stderr .
exists ../detached-sha
exec git -C ../detached-sha rev-parse --abbrev-ref HEAD
stdout '^HEAD$'

## Error: --detach with nonexistent ref

! exec grove add --detach nonexistent-ref-12345
stderr 'does not exist'

## Success: --name uses custom directory name

exec grove add --name custom-dir-name feature/custom-name-test
stdout 'Created worktree at .*/custom-dir-name'
! stderr .
exists ../custom-dir-name
# Verify branch name is still the original
exec git -C ../custom-dir-name rev-parse --abbrev-ref HEAD
stdout '^feature/custom-name-test$'

## Success: --name with path separators creates nested directories

exec grove add --name 'nested/dir' feature/slash-name-test
stdout 'Created worktree at .*/nested/dir'
! stderr .
exists ../nested/dir
exec git -C ../nested/dir rev-parse --abbrev-ref HEAD
stdout '^feature/slash-name-test$'

## Success: Empty --name falls back to default naming

exec grove add --name '' feature/empty-name-test
stdout 'Created worktree at .*/feature-empty-name-test'
! stderr .
exists ../feature-empty-name-test

## Error: --base with branch that has worktree

! exec grove add --base main existing-branch
stderr 'worktree already exists'

## Success: From workspace root

cd $WORK/workspace
exec grove add feature/from-root
stdout 'Created worktree at .*/feature-from-root'
! stderr .
exists feature-from-root

## Success: Preserved files shown in output

cd $WORK/workspace/main
# Create .gitignore with .env pattern (required for preservation)
exec sh -c 'echo ".env" > .gitignore'
exec git add .gitignore
exec git commit -m 'add gitignore'
# Create .env file to be preserved
exec sh -c 'echo "SECRET=value" > .env'
exec grove add feature/preserve-test
stdout 'Created worktree at .*/feature-preserve-test'
stdout 'preserved'
exists ../feature-preserve-test/.env

## Error: --base with existing branch (no worktree)

cd $WORK/workspace/main
exec git branch no-worktree-branch
! exec grove add --base main no-worktree-branch
stderr 'cannot be used with existing branch'

## Success: Existing remote branch creates worktree

# Create a branch on the remote
exec git -C $WORK/testrepo checkout -b remote-only-branch
exec git -C $WORK/testrepo checkout main
# Fetch from remote
cd $WORK/workspace/.bare
exec git fetch origin
cd $WORK/workspace/main
exec grove add remote-only-branch
stdout 'Created worktree at .*/remote-only-branch'
exists ../remote-only-branch
# Verify branch was created
exec git -C ../remote-only-branch rev-parse --abbrev-ref HEAD
stdout '^remote-only-branch$'

## Auto-lock: Feature branch not locked

# Create .grove.toml with auto-lock for main
exec sh -c 'echo "[auto-lock]" > $WORK/workspace/main/.grove.toml'
exec sh -c 'echo "patterns = [\"main\", \"release/*\"]" >> $WORK/workspace/main/.grove.toml'
exec grove add feature/autolock-test
# feature branch should NOT be locked
exec git -C $WORK/workspace/.bare worktree list --porcelain
! stdout 'locked.*feature-autolock-test'

## Auto-lock: Release branch locked by pattern

exec grove add release/v1.0
stdout 'Created worktree at .*/release-v1.0'
# release branch SHOULD be locked
exec git -C $WORK/workspace/.bare worktree list --porcelain
stdout 'locked'

## Hooks: Success shown in output

cd $WORK/workspace/main
# Configure a simple hook that creates a marker file
exec sh -c 'echo "[hooks]" > .grove.toml'
exec sh -c 'echo "add = [\"touch .hook-ran\"]" >> .grove.toml'
exec grove add feature/hook-success
stdout 'Created worktree at .*/feature-hook-success'
stdout 'ran 1 hook'
stdout 'touch .hook-ran'
# Verify hook actually ran
exists ../feature-hook-success/.hook-ran

## Hooks: Multiple hooks all succeed

exec sh -c 'echo "[hooks]" > .grove.toml'
exec sh -c 'echo "add = [\"touch .hook1\", \"touch .hook2\"]" >> .grove.toml'
exec grove add feature/multi-hook
stdout 'Created worktree at .*/feature-multi-hook'
stdout 'ran 2 hooks'
exists ../feature-multi-hook/.hook1
exists ../feature-multi-hook/.hook2

## Hooks: Failure warning shown

exec sh -c 'echo "[hooks]" > .grove.toml'
exec sh -c 'echo "add = [\"exit 1\"]" >> .grove.toml'
exec grove add feature/hook-fail
stdout 'Created worktree at .*/feature-hook-fail'
stdout 'Hook failed.*exit 1.*exit code 1'
exists ../feature-hook-fail

## Hooks: Stops at first failure

exec sh -c 'echo "[hooks]" > .grove.toml'
exec sh -c 'echo "add = [\"exit 42\", \"touch .should-not-exist\"]" >> .grove.toml'
exec grove add feature/hook-stop-early
stdout 'Created worktree at .*/feature-hook-stop-early'
stdout 'Hook failed.*exit 42.*exit code 42'
exists ../feature-hook-stop-early
! exists ../feature-hook-stop-early/.should-not-exist

## Hooks: No output when none configured

exec sh -c 'echo "[hooks]" > .grove.toml'
exec sh -c 'echo "add = []" >> .grove.toml'
exec grove add feature/no-hooks
stdout 'Created worktree at .*/feature-no-hooks'
! stdout 'ran.*hook'
! stderr 'Hook'

## Hooks: Invalid TOML shows warning

exec sh -c 'echo "this is not valid toml [[[" > .grove.toml'
exec grove add feature/invalid-toml
stdout 'Created worktree at .*/feature-invalid-toml'
stdout 'hooks disabled'
exists ../feature-invalid-toml

# Restore valid config for any subsequent tests
exec sh -c 'echo "" > .grove.toml'

## Detached worktree not auto-locked (no branch to match patterns)

# Configure auto-lock patterns
exec sh -c 'echo "[auto-lock]" > .grove.toml'
exec sh -c 'echo "patterns = [\"*\"]" >> .grove.toml'
# Create detached worktree from tag
exec grove add --detach v1.0.0 --name detached-lock-test
stdout 'Created detached worktree at .*/detached-lock-test'
# Detached worktrees should NOT be locked (no branch name to match)
exec git -C $WORK/workspace/.bare worktree list --porcelain
! stdout 'worktree.*detached-lock-test.*locked'

# Clean up config for remaining tests
exec sh -c 'echo "" > .grove.toml'

## Very long branch name (200+ chars) - tests filesystem handling

# Create a branch name that's very long (but under typical 255 limit)
exec grove add feature/this-is-a-very-long-branch-name-that-tests-how-grove-handles-extremely-lengthy-branch-names-which-might-approach-filesystem-limits-on-some-systems-especially-windows
stdout 'Created worktree at'
exists ../feature-this-is-a-very-long-branch-name-that-tests-how-grove-handles-extremely-lengthy-branch-names-which-might-approach-filesystem-limits-on-some-systems-especially-windows

## Merge in progress in source worktree - should not affect add

cd $WORK/workspace/main
# Create a branch with conflicting changes
exec git checkout -b merge-source
exec sh -c 'echo "source content" > conflict.txt'
exec git add conflict.txt
exec git commit -m 'add conflict file on merge-source'
exec git checkout main
exec git checkout -b merge-target
exec sh -c 'echo "target content" > conflict.txt'
exec git add conflict.txt
exec git commit -m 'add conflict file on merge-target'
# Start merge that will conflict
! exec git merge merge-source
# Verify we're in merge state
exec git status
stdout 'Unmerged paths'
# grove add should still work from this worktree
exec grove add feature/during-merge
stdout 'Created worktree at .*/feature-during-merge'
exists ../feature-during-merge
# Clean up merge state
exec git merge --abort
exec git checkout main

## Rebase in progress in source worktree - should not affect add

cd $WORK/workspace/main
# Create branches for rebase conflict
exec git checkout -b rebase-base
exec sh -c 'echo "base content" > rebase-file.txt'
exec git add rebase-file.txt
exec git commit -m 'base commit'
exec git checkout -b rebase-feature
exec sh -c 'echo "feature content" > rebase-file.txt'
exec git add rebase-file.txt
exec git commit -m 'feature commit'
exec git checkout rebase-base
exec sh -c 'echo "conflicting base" > rebase-file.txt'
exec git add rebase-file.txt
exec git commit -m 'conflicting base commit'
exec git checkout rebase-feature
# Start rebase that will conflict
! exec git rebase rebase-base
# Verify we're in rebase state
exec git status
stdout 'rebase in progress'
# grove add should still work
exec grove add feature/during-rebase
stdout 'Created worktree at .*/feature-during-rebase'
exists ../feature-during-rebase
# Clean up rebase state
exec git rebase --abort
exec git checkout main

## Directory collision after sanitization

cd $WORK/workspace/main
# Create first branch with slash
exec grove add feature/collision-test
stdout 'Created worktree at .*/feature-collision-test'
exists ../feature-collision-test
# Try to create branch that sanitizes to same directory name
# feature\collision-test on Windows or just testing the error
! exec grove add --name feature-collision-test feature/other-branch
stderr 'directory already exists'

## Git config patterns for preservation (no TOML config)

cd $WORK/workspace/main
# Remove TOML config to test git config fallback
exec rm -f .grove.toml
# Ensure .env exists and is gitignored for this test
exec sh -c 'echo "GIT_CONFIG_TEST=value" > .env-gitconfig'
exec sh -c 'echo ".env-gitconfig" >> .gitignore'
exec git add .gitignore
exec git commit -m 'gitignore env-gitconfig' --allow-empty
# Set git config for preservation (unquoted value)
exec git config grove.preserve .env-gitconfig
# Verify git config is set
exec git config --get-all grove.preserve
stdout '.env-gitconfig'
# Create worktree - should preserve via git config pattern
exec grove add feature/git-config-preserve
stdout 'Created worktree at .*/feature-git-config-preserve'
stdout 'preserved'
stdout '.env-gitconfig'
exists ../feature-git-config-preserve/.env-gitconfig
# Clean up git config
exec git config --unset grove.preserve

## Empty repository edge case (init new with no commits)
# This tests grove init new + add behavior with an empty repo

cd $WORK
mkdir empty-workspace
exec grove init new empty-workspace
cd empty-workspace
# Grove init new creates just bare repo, no worktrees yet
# Adding a worktree in empty repo creates orphan branch
exec grove add feature/test
stdout 'Created worktree at .*/feature-test'
exists feature-test
exists feature-test/.git

## Lock cleanup on success → lock file removed

cd $WORK/workspace/main
# Verify no lock file exists before operation
! exists ../.grove-worktree.lock
exec grove add feature/lock-test-success
stdout 'Created worktree at'
exists ../feature-lock-test-success
# Verify lock file was cleaned up after successful operation
! exists ../.grove-worktree.lock

## Lock cleanup on failure → lock file removed

# Try to add a branch that will fail (directory already exists)
mkdir ../lock-fail-dir
! exec grove add lock-fail-dir
stderr 'directory already exists'
# Verify lock file was cleaned up even after failure
! exists ../.grove-worktree.lock

## Skipped files listed → shows already-existing files

cd $WORK/workspace/main
# Create a file that will be skipped during preservation
exec sh -c 'echo "SKIP_TEST=1" > .env-skip-test'
exec sh -c 'echo ".env-skip-test" >> .gitignore'
exec git add .gitignore
exec git commit -m 'add env-skip-test to gitignore'
# Create destination with file already present
exec grove add feature/skip-test
exists ../feature-skip-test
# Create the file in destination before second add
exec sh -c 'echo "EXISTING=1" > ../feature-skip-test/.env-skip-test'
# Remove the worktree and re-add (file will be skipped)
exec grove remove feature-skip-test
# Re-add - the existing file should be skipped
exec sh -c 'echo "SKIP_TEST=modified" > .env-skip-test'
exec grove add feature/skip-test-2
stdout 'Created worktree at'
# Note: skipped files are only shown when there are preserved files AND skipped files
# This verifies the preservation mechanism works

-- README.md --
# Test

---
phase: 01-core-fetch
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
    - internal/git/fetch.go
    - internal/git/fetch_test.go
autonomous: true

must_haves:
    truths:
        - 'Ref snapshots capture all remote-tracking refs for comparison'
        - 'Changes are detected by comparing before/after snapshots'
        - 'Fetch operation prunes stale refs automatically'
        - 'Failed fetches retry once before reporting error'
    artifacts:
        - path: 'internal/git/fetch.go'
          provides: 'Git fetch operations and change detection'
          exports:
              [
                  'FetchRemote',
                  'GetRemoteRefs',
                  'DetectRefChanges',
                  'RefChange',
                  'ChangeType',
              ]
        - path: 'internal/git/fetch_test.go'
          provides: 'Unit tests for fetch operations'
          min_lines: 100
    key_links:
        - from: 'internal/git/fetch.go'
          to: 'git for-each-ref'
          via: 'GitCommand wrapper'
          pattern: 'for-each-ref.*refs/remotes'
        - from: 'internal/git/fetch.go'
          to: 'git fetch --prune'
          via: 'GitCommand wrapper'
          pattern: 'fetch.*--prune'
---

<objective>
Implement git fetch operations with ref change detection using TDD.

Purpose: Provide reliable ref snapshot capture and change detection for the fetch command. The ref comparison logic must correctly identify new, updated, and pruned refs.

Output: `internal/git/fetch.go` with tested functions for fetching remotes and detecting ref changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-fetch/01-CONTEXT.md
@.planning/phases/01-core-fetch/01-RESEARCH.md
@internal/git/git.go
@internal/git/status.go
@internal/testutil/git/git.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for ref operations</name>
  <files>internal/git/fetch_test.go</files>
  <action>
    Create fetch_test.go with tests written BEFORE implementation (TDD):

    TestGetRemoteRefs:
    - Test with valid remote: returns map of refs to commit hashes
    - Test with missing remote: returns error
    - Use testutil.TestRepo to set up test repository with known refs

    TestDetectRefChanges (pure function, no git needed):
    - Test new refs: before={}, after={x:A} -> [RefChange{x, "", A, New}]
    - Test updated refs: before={x:A}, after={x:B} -> [RefChange{x, A, B, Updated}]
    - Test pruned refs: before={x:A}, after={} -> [RefChange{x, A, "", Pruned}]
    - Test unchanged refs: before={x:A}, after={x:A} -> []
    - Test mixed changes: combination of above

    TestFetchRemote:
    - Test successful fetch
    - Test fetch failure (non-existent remote)

    Define types in test file first (will fail to compile until implemented):
    - ChangeType type
    - RefChange struct

  </action>
  <verify>`go build ./internal/git/...` should fail (expected - tests before implementation)</verify>
  <done>Test file exists with comprehensive test cases, compilation fails due to missing types</done>
</task>

<task type="auto">
  <name>Task 2: Implement types and DetectRefChanges</name>
  <files>internal/git/fetch.go</files>
  <action>
    Create fetch.go with types and pure function first:

    Types:
    ```go
    type ChangeType int
    const (
        New ChangeType = iota
        Updated
        Pruned
    )

    type RefChange struct {
        RefName string
        OldHash string
        NewHash string
        Type    ChangeType
    }
    ```

    DetectRefChanges(before, after map[string]string) []RefChange:
    - Iterate 'after' map: if not in 'before' -> New, if in 'before' but hash differs -> Updated
    - Iterate 'before' map: if not in 'after' -> Pruned
    - Skip unchanged refs (same hash in both)

    This is a pure function - no git operations, easy to test.

  </action>
  <verify>`make test` - DetectRefChanges tests should pass</verify>
  <done>Types defined, DetectRefChanges tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Implement GetRemoteRefs and FetchRemote</name>
  <files>internal/git/fetch.go</files>
  <action>
    GetRemoteRefs(repoPath, remote string) (map[string]string, error):
    - Use git for-each-ref --format=%(refname) %(objectname) refs/remotes/{remote}/
    - Use GitCommand wrapper for timeout support
    - Parse output into map[refName]commitHash
    - Return error if command fails

    FetchRemote(repoPath, remote string) error:
    - Execute git fetch --prune {remote}
    - Use GitCommand wrapper
    - Return error with stderr context if fetch fails

    Follow existing patterns from internal/git/git.go:
    - Use executeWithOutputBuffer for parsing
    - Error wrapping with fmt.Errorf and %w

  </action>
  <verify>`make test` - all fetch_test.go tests should pass</verify>
  <done>All tests pass, functions implemented following Grove patterns</done>
</task>

</tasks>

<feature>
  <name>Ref change detection</name>
  <files>internal/git/fetch.go, internal/git/fetch_test.go</files>
  <behavior>
    GetRemoteRefs(repoPath, remote) returns map[refName]commitHash for all refs under refs/remotes/{remote}/

    DetectRefChanges(before, after map[string]string) returns []RefChange:
    - New refs: in 'after' but not in 'before' -> ChangeType: New
    - Updated refs: in both but hash differs -> ChangeType: Updated
    - Pruned refs: in 'before' but not in 'after' -> ChangeType: Pruned

    Cases:
    - empty before + populated after -> all New
    - populated before + empty after -> all Pruned
    - before[x]=A, after[x]=B -> Updated
    - before[x]=A, after[x]=A -> no change (not in result)

  </behavior>
  <implementation>
    Types:
    - ChangeType enum: New, Updated, Pruned
    - RefChange struct: RefName, OldHash, NewHash, Type

    GetRemoteRefs: Use git for-each-ref --format=%(refname) %(objectname) refs/remotes/{remote}/

    FetchRemote: Execute git fetch --prune {remote}, capture exit code, return error with stderr context

    DetectRefChanges: Pure function comparing two maps, returns slice of RefChange

    Follow existing patterns:
    - Use GitCommand wrapper for timeout support
    - Use executeWithOutputBuffer for parsing
    - Error wrapping with fmt.Errorf and %w

  </implementation>
</feature>

<verification>
```bash
cd /home/sqve/code/personal/grove/main && make test
```

Tests must:

- Pass for GetRemoteRefs with valid remote
- Pass for GetRemoteRefs with invalid/missing remote (error case)
- Pass for DetectRefChanges with all change type combinations
- Pass for FetchRemote success and failure cases
  </verification>

<success_criteria>

- All tests pass with `make test`
- GetRemoteRefs returns correct ref map from test repo
- DetectRefChanges correctly identifies New/Updated/Pruned refs
- FetchRemote executes git fetch with --prune flag
- Code follows Grove error handling patterns (fmt.Errorf with %w)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-core-fetch/01-01-SUMMARY.md`
</output>

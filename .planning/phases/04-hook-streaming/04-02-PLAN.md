---
phase: 04-hook-streaming
plan: 02
type: execute
wave: 2
depends_on: ['04-01']
files_modified:
    - internal/hooks/streaming.go
    - internal/hooks/streaming_test.go
    - cmd/grove/commands/add.go
autonomous: true

must_haves:
    truths:
        - 'Hook stdout streams to terminal as hook executes'
        - 'Hook stderr streams to terminal as hook executes'
        - 'Each line of hook output shows which hook is running'
        - 'No spinner animation during hook streaming'
        - 'Hook output goes to stderr (not stdout)'
    artifacts:
        - path: 'internal/hooks/streaming.go'
          provides: 'RunAddHooksStreaming function'
          exports: ['RunAddHooksStreaming']
        - path: 'internal/hooks/streaming_test.go'
          provides: 'Streaming execution tests'
          contains: 'TestRunAddHooksStreaming'
        - path: 'cmd/grove/commands/add.go'
          provides: 'Wired streaming hooks'
          contains: 'RunAddHooksStreaming'
    key_links:
        - from: 'internal/hooks/streaming.go'
          to: 'os/exec'
          via: 'cmd.Start() and cmd.Wait() pattern'
          pattern: "cmd\\.Start\\(\\)"
        - from: 'cmd/grove/commands/add.go'
          to: 'internal/hooks/streaming.go'
          via: 'hooks.RunAddHooksStreaming call'
          pattern: "hooks\\.RunAddHooksStreaming"
---

<objective>
Create RunAddHooksStreaming function and integrate it into grove add command.

Purpose: Completes STRM-01 (hook output streams in real-time) by replacing buffered execution with streaming. Users now see hook progress during long-running operations like npm install instead of waiting in silence.

Output: Streaming hook execution in `internal/hooks/streaming.go`, updated `cmd/grove/commands/add.go` to use streaming.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-hook-streaming/04-RESEARCH.md
@.planning/phases/04-hook-streaming/04-01-SUMMARY.md

@internal/hooks/hooks.go
@internal/hooks/streaming.go
@internal/logger/logger.go
@internal/styles/styles.go
@cmd/grove/commands/add.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RunAddHooksStreaming function</name>
  <files>internal/hooks/streaming.go, internal/hooks/streaming_test.go</files>
  <action>
Add RunAddHooksStreaming function to streaming.go:

```go
func RunAddHooksStreaming(workDir string, commands []string, output io.Writer) *RunResult {
    result := &RunResult{}
    if len(commands) == 0 {
        return result
    }

    logger.Debug("Running %d add hooks in %s (streaming)", len(commands), workDir)

    for _, cmdStr := range commands {
        logger.Debug("Executing hook: %s", cmdStr)

        cmd := exec.Command("sh", "-c", cmdStr)
        cmd.Dir = workDir

        // Create prefix writers for stdout/stderr
        // Use styles.Render for dimmed prefix, output to provided writer
        prefix := styles.Render(&styles.Dimmed, fmt.Sprintf("  [%s]", cmdStr))
        stdout := NewPrefixWriter(prefix, output)
        stderr := NewPrefixWriter(prefix, output)

        cmd.Stdout = stdout
        cmd.Stderr = stderr

        // CRITICAL: Use Start() then Wait(), not Run()
        // Run() with assigned Stdout/Stderr can cause issues
        err := cmd.Start()
        if err != nil {
            result.Failed = &HookResult{
                Command:  cmdStr,
                ExitCode: 1,
                Stdout:   "",
                Stderr:   err.Error(),
            }
            return result
        }

        err = cmd.Wait()

        // Flush any remaining buffered output
        _ = stdout.Flush()
        _ = stderr.Flush()

        if err != nil {
            exitCode := 1
            var exitErr *exec.ExitError
            if errors.As(err, &exitErr) {
                exitCode = exitErr.ExitCode()
            }
            result.Failed = &HookResult{
                Command:  cmdStr,
                ExitCode: exitCode,
                Stdout:   "",  // Already streamed
                Stderr:   "",  // Already streamed
            }
            logger.Debug("Hook failed with exit code %d: %s", exitCode, cmdStr)
            return result
        }

        result.Succeeded = append(result.Succeeded, cmdStr)
        logger.Debug("Hook succeeded: %s", cmdStr)
    }
    return result
}
```

Function signature takes `output io.Writer` parameter (typically os.Stderr) for testability.

Add required imports: "errors", "os/exec", "github.com/sqve/grove/internal/styles".

Add test in streaming_test.go:

- Test output contains prefix and hook output
- Test failed hook sets Failed field correctly
- Test empty commands returns empty result
- Use bytes.Buffer as output for capturing in tests
  </action>
  <verify>`make test` passes, specifically `go test ./internal/hooks/... -run TestRunAddHooksStreaming`</verify>
  <done>RunAddHooksStreaming function exists, streams output with prefix, tests pass</done>
  </task>

<task type="auto">
  <name>Task 2: Integrate streaming hooks into add.go</name>
  <files>cmd/grove/commands/add.go</files>
  <action>
Update runAddHooks function in add.go to use streaming:

1. Change function to call hooks.RunAddHooksStreaming instead of hooks.RunAddHooks:

```go
func runAddHooks(sourceWorktree, destWorktree string) *hooks.RunResult {
    var addHooks []string
    if sourceWorktree != "" {
        addHooks = hooks.GetAddHooks(sourceWorktree)
    }

    if len(addHooks) == 0 {
        logger.Debug("No add hooks configured")
        return nil
    }

    // Show that hooks are starting (no spinner - output streams directly)
    logger.Info("Running %d hook(s)...", len(addHooks))

    // Stream hooks to stderr
    return hooks.RunAddHooksStreaming(destWorktree, addHooks, os.Stderr)
}
```

2. Update logHookResult to not re-display hook commands (they were already shown during streaming):

```go
func logHookResult(result *hooks.RunResult) {
    if result == nil {
        return
    }

    // Don't show succeeded hooks - they already streamed their output
    // Just show summary for failures
    if result.Failed != nil {
        logger.Warning("Hook failed: %s (exit code %d)", result.Failed.Command, result.Failed.ExitCode)
    }
}
```

3. Add "os" import if not present (for os.Stderr).

Key changes:

- Replace hooks.RunAddHooks with hooks.RunAddHooksStreaming
- Remove spinner (no spinner during streaming per research guidance)
- Simplify logHookResult since output already streamed
- Use logger.Info for starting message, not spinner
  </action>
  <verify>`make test` passes, `make build` succeeds</verify>
  <done>grove add uses streaming hooks, output shows prefixed hook lines during execution</done>
  </task>

<task type="auto">
  <name>Task 3: Add integration test for streaming behavior</name>
  <files>internal/hooks/streaming_test.go</files>
  <action>
Add integration-style test that verifies end-to-end streaming behavior:

```go
func TestRunAddHooksStreaming(t *testing.T) {
    t.Run("streams output with prefix", func(t *testing.T) {
        workDir := t.TempDir()
        var output bytes.Buffer

        commands := []string{"echo 'line 1'; echo 'line 2'"}
        result := RunAddHooksStreaming(workDir, commands, &output)

        // Verify success
        if len(result.Succeeded) != 1 {
            t.Errorf("Expected 1 succeeded, got %d", len(result.Succeeded))
        }

        // Verify output contains prefixed lines
        out := output.String()
        if !strings.Contains(out, "[echo") {
            t.Error("Expected prefix in output")
        }
        if !strings.Contains(out, "line 1") || !strings.Contains(out, "line 2") {
            t.Error("Expected hook output")
        }
    })

    t.Run("handles command without trailing newline", func(t *testing.T) {
        workDir := t.TempDir()
        var output bytes.Buffer

        commands := []string{"echo -n 'no newline'"}
        result := RunAddHooksStreaming(workDir, commands, &output)

        if len(result.Succeeded) != 1 {
            t.Errorf("Expected success, got %d succeeded", len(result.Succeeded))
        }

        out := output.String()
        if !strings.Contains(out, "no newline") {
            t.Error("Expected output from command without newline")
        }
    })

    t.Run("stops on first failure", func(t *testing.T) {
        workDir := t.TempDir()
        var output bytes.Buffer

        commands := []string{"echo 'first'", "false", "echo 'third'"}
        result := RunAddHooksStreaming(workDir, commands, &output)

        if len(result.Succeeded) != 1 {
            t.Errorf("Expected 1 succeeded, got %d", len(result.Succeeded))
        }
        if result.Failed == nil {
            t.Fatal("Expected failure")
        }
        if result.Failed.Command != "false" {
            t.Errorf("Expected 'false' to fail, got %q", result.Failed.Command)
        }
    })

    t.Run("returns empty result for empty commands", func(t *testing.T) {
        workDir := t.TempDir()
        var output bytes.Buffer

        result := RunAddHooksStreaming(workDir, nil, &output)

        if len(result.Succeeded) != 0 || result.Failed != nil {
            t.Error("Expected empty result")
        }
    })

    t.Run("captures exit code on failure", func(t *testing.T) {
        workDir := t.TempDir()
        var output bytes.Buffer

        commands := []string{"exit 42"}
        result := RunAddHooksStreaming(workDir, commands, &output)

        if result.Failed == nil {
            t.Fatal("Expected failure")
        }
        if result.Failed.ExitCode != 42 {
            t.Errorf("Expected exit code 42, got %d", result.Failed.ExitCode)
        }
    })
}
```

Add required imports: "bytes", "strings".
</action>
<verify>`make test` passes with all streaming tests</verify>
<done>Integration tests verify streaming behavior, prefix format, failure handling</done>
</task>

</tasks>

<verification>
- `make test` passes all hook tests
- `make lint` passes
- `make build` succeeds
- Manual test: Create worktree with hook configured, verify output streams with prefix
</verification>

<success_criteria>

- RunAddHooksStreaming function exists and streams output
- add.go uses RunAddHooksStreaming instead of RunAddHooks
- Hook output appears with prefix during execution (not after)
- Output goes to stderr (not stdout)
- Existing hook tests still pass
  </success_criteria>

<output>
After completion, create `.planning/phases/04-hook-streaming/04-02-SUMMARY.md`
</output>

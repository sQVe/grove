---
phase: 04-hook-streaming
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
    - internal/hooks/streaming.go
    - internal/hooks/streaming_test.go
autonomous: true

must_haves:
    truths:
        - 'PrefixWriter emits complete lines with prefix'
        - 'Incomplete lines are buffered until newline received'
        - 'Flush() emits any remaining buffered content'
        - 'Output without trailing newline is handled correctly'
    artifacts:
        - path: 'internal/hooks/streaming.go'
          provides: 'PrefixWriter type with Write and Flush'
          exports: ['PrefixWriter', 'NewPrefixWriter']
          min_lines: 40
        - path: 'internal/hooks/streaming_test.go'
          provides: 'PrefixWriter behavior tests'
          contains: 'TestPrefixWriter'
    key_links:
        - from: 'internal/hooks/streaming.go'
          to: 'io.Writer'
          via: 'implements io.Writer interface'
          pattern: "func \\(w \\*PrefixWriter\\) Write"
---

<objective>
Create a PrefixWriter type that wraps an io.Writer and prefixes each complete line with a given string.

Purpose: Enables hook output streaming where each line is prefixed with the hook command, so users know which hook produced each line of output. This is the core building block for STRM-02 (hook output includes prefix identifying which hook is running).

Output: `internal/hooks/streaming.go` with tested PrefixWriter type, `internal/hooks/streaming_test.go` with behavior tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-hook-streaming/04-RESEARCH.md

@internal/hooks/hooks.go
@internal/hooks/hooks_test.go
</context>

<feature>
  <name>PrefixWriter for line-by-line output with prefix</name>
  <files>internal/hooks/streaming.go, internal/hooks/streaming_test.go</files>
  <behavior>
    PrefixWriter implements io.Writer. It buffers input and emits complete lines with a prefix.

    API contract:
    - NewPrefixWriter(prefix string, target io.Writer) *PrefixWriter
    - Write(p []byte) (n int, err error) - buffers input, emits complete lines with prefix
    - Flush() error - emits any remaining buffered content with prefix and newline

    Behavior:
    - Input "hello\n" with prefix "[hook]" produces "[hook] hello\n"
    - Input "hello\nworld\n" produces two prefixed lines
    - Input "hello" (no newline) buffers until more input or Flush()
    - Input across multiple Write() calls assembles correctly
    - Flush() on partial line adds prefix and newline

    Test cases:
    - Single complete line: Write("line\n") -> "[prefix] line\n"
    - Multiple lines: Write("a\nb\n") -> "[prefix] a\n[prefix] b\n"
    - Partial line: Write("partial") then Flush() -> "[prefix] partial\n"
    - Split line: Write("hel") then Write("lo\n") -> "[prefix] hello\n"
    - Empty buffer: Flush() on empty buffer -> no output
    - Mixed: Write("a\nb") then Flush() -> "[prefix] a\n[prefix] b\n"

  </behavior>
  <implementation>
    Create internal/hooks/streaming.go:

    ```go
    type PrefixWriter struct {
        prefix string
        target io.Writer
        buf    bytes.Buffer
    }

    func NewPrefixWriter(prefix string, target io.Writer) *PrefixWriter {
        return &PrefixWriter{prefix: prefix, target: target}
    }

    func (w *PrefixWriter) Write(p []byte) (n int, err error) {
        // Write to internal buffer
        n, err = w.buf.Write(p)
        if err != nil {
            return n, err
        }

        // Process complete lines
        for {
            line, err := w.buf.ReadString('\n')
            if err != nil {
                // No complete line - put back incomplete data
                if line != "" {
                    w.buf.WriteString(line)
                }
                break
            }
            // Emit line with prefix
            _, writeErr := fmt.Fprintf(w.target, "%s %s", w.prefix, line)
            if writeErr != nil {
                return n, writeErr
            }
        }
        return n, nil
    }

    func (w *PrefixWriter) Flush() error {
        remaining := w.buf.String()
        if remaining != "" {
            _, err := fmt.Fprintf(w.target, "%s %s\n", w.prefix, remaining)
            w.buf.Reset()
            return err
        }
        return nil
    }
    ```

    Follow patterns from 04-RESEARCH.md code examples.

  </implementation>
</feature>

<verification>
- `make test` passes with new streaming tests
- `make lint` passes
- Test coverage includes all documented behaviors
</verification>

<success_criteria>

- PrefixWriter type exists with Write() and Flush() methods
- Write() implements io.Writer interface
- Tests cover: single line, multiple lines, partial lines, split lines, flush
- No changes to existing hooks.go (that's plan 02)
  </success_criteria>

<output>
After completion, create `.planning/phases/04-hook-streaming/04-01-SUMMARY.md`
</output>
